"""
Bytecode compiler - compiles AST to bytecode.

This module provides the BytecodeCompiler class which traverses a JavaScript
AST and generates bytecode instructions.

Public API:
    - BytecodeCompiler: AST to bytecode compiler
    - CompileError: Compilation error exception
"""

from typing import Dict

from .opcode import Opcode
from .instruction import Instruction
from .bytecode_array import BytecodeArray

from components.parser.src.ast_nodes import (
    Program,
    Expression,
    Statement,
    Literal,
    Identifier,
    TemplateLiteral,
    BinaryExpression,
    ExpressionStatement,
    VariableDeclaration,
    ReturnStatement,
    FunctionDeclaration,
    CallExpression,
    ArrayExpression,
    ObjectExpression,
    Property,
    Pattern,
    ObjectPattern,
    ArrayPattern,
    PropertyPattern,
    AssignmentPattern,
    ArrowFunctionExpression,
    BlockStatement,
    MemberExpression,
    IfStatement,
    WhileStatement,
    ForStatement,
    ForInStatement,
    ForOfStatement,
)


class CompileError(Exception):
    """Exception raised during bytecode compilation."""

    pass


class BytecodeCompiler:
    """
    Compiles JavaScript AST to bytecode.

    This class traverses an Abstract Syntax Tree (AST) and generates
    bytecode instructions for execution by the virtual machine.

    Attributes:
        ast: The Program AST node to compile
        bytecode: The generated bytecode array

    Example:
        >>> from components.parser.src import Parse
        >>> from components.bytecode.src.compiler import BytecodeCompiler
        >>>
        >>> ast = Parse("var x = 42;")
        >>> compiler = BytecodeCompiler(ast)
        >>> bytecode = compiler.compile()
        >>> len(bytecode.instructions) > 0
        True
    """

    def __init__(self, ast: Program):
        """
        Initialize BytecodeCompiler with AST.

        Args:
            ast: Program AST node to compile
        """
        self.ast = ast
        self.bytecode = BytecodeArray()
        self.locals: Dict[str, int] = {}  # variable name -> local index
        self.next_local_index = 0

    def compile(self) -> BytecodeArray:
        """
        Compile AST to bytecode.

        Traverses the AST and generates bytecode instructions.

        Returns:
            BytecodeArray containing compiled bytecode

        Raises:
            CompileError: If compilation fails

        Example:
            >>> from components.parser.src.ast_nodes import Program
            >>> from components.bytecode.src.compiler import BytecodeCompiler
            >>>
            >>> ast = Program(body=[])
            >>> compiler = BytecodeCompiler(ast)
            >>> bytecode = compiler.compile()
            >>> len(bytecode.instructions) >= 1
            True
        """
        try:
            # Compile program body
            statements = self.ast.body
            for i, statement in enumerate(statements):
                is_last = i == len(statements) - 1
                self._compile_statement(statement, is_last_statement=is_last)

            # Check if last statement was an ExpressionStatement that kept its value
            # If not, add implicit return undefined
            if not statements or not isinstance(statements[-1], ExpressionStatement):
                self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_UNDEFINED))

            self.bytecode.add_instruction(Instruction(opcode=Opcode.RETURN))

            # Set local count
            self.bytecode.local_count = self.next_local_index

            return self.bytecode

        except Exception as e:
            raise CompileError(f"Compilation failed: {e}") from e

    def _compile_statement(
        self, stmt: Statement, is_last_statement: bool = False
    ) -> None:
        """Compile a statement node."""
        if isinstance(stmt, ExpressionStatement):
            self._compile_expression(stmt.expression)
            # Pop expression result unless it's the last statement (for eval/REPL mode)
            if not is_last_statement:
                self.bytecode.add_instruction(Instruction(opcode=Opcode.POP))

        elif isinstance(stmt, VariableDeclaration):
            self._compile_variable_declaration(stmt)

        elif isinstance(stmt, ReturnStatement):
            if stmt.argument:
                self._compile_expression(stmt.argument)
            else:
                self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_UNDEFINED))
            self.bytecode.add_instruction(Instruction(opcode=Opcode.RETURN))

        elif isinstance(stmt, FunctionDeclaration):
            self._compile_function_declaration(stmt)

        elif isinstance(stmt, IfStatement):
            self._compile_if_statement(stmt)

        elif isinstance(stmt, WhileStatement):
            self._compile_while_statement(stmt)

        elif isinstance(stmt, ForStatement):
            self._compile_for_statement(stmt)

        elif isinstance(stmt, ForInStatement):
            self._compile_for_in_statement(stmt)

        elif isinstance(stmt, ForOfStatement):
            self._compile_for_of_statement(stmt)

        elif isinstance(stmt, BlockStatement):
            # Compile each statement in the block
            for statement in stmt.body:
                self._compile_statement(statement)

        else:
            raise CompileError(f"Unsupported statement type: {type(stmt).__name__}")

    def _compile_expression(self, expr: Expression) -> None:
        """Compile an expression node."""
        if isinstance(expr, Literal):
            self._compile_literal(expr)

        elif isinstance(expr, Identifier):
            self._compile_identifier(expr)

        elif isinstance(expr, BinaryExpression):
            self._compile_binary_expression(expr)

        elif isinstance(expr, CallExpression):
            # Simplified: Basic function call
            self._compile_call_expression(expr)

        elif isinstance(expr, ArrayExpression):
            self._compile_array_expression(expr)

        elif isinstance(expr, ObjectExpression):
            self._compile_object_expression(expr)

        elif isinstance(expr, ArrowFunctionExpression):
            self._compile_arrow_function_expression(expr)

        elif isinstance(expr, MemberExpression):
            self._compile_member_expression(expr)

        elif isinstance(expr, TemplateLiteral):
            self._compile_template_literal(expr)

        else:
            raise CompileError(f"Unsupported expression type: {type(expr).__name__}")

    def _compile_literal(self, lit: Literal) -> None:
        """Compile a literal value."""
        value = lit.value

        if value is None:
            self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_NULL))
        elif value is True:
            self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_TRUE))
        elif value is False:
            self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_FALSE))
        else:
            # Add to constant pool and emit LOAD_CONSTANT
            const_index = self.bytecode.add_constant(value)
            self.bytecode.add_instruction(
                Instruction(opcode=Opcode.LOAD_CONSTANT, operand1=const_index)
            )

    def _compile_identifier(self, ident: Identifier) -> None:
        """Compile an identifier (variable reference)."""
        name = ident.name

        # Check if it's a local variable
        if name in self.locals:
            local_index = self.locals[name]
            self.bytecode.add_instruction(
                Instruction(opcode=Opcode.LOAD_LOCAL, operand1=local_index)
            )
        else:
            # Treat as global
            name_index = self.bytecode.add_constant(name)
            self.bytecode.add_instruction(
                Instruction(opcode=Opcode.LOAD_GLOBAL, operand1=name_index)
            )

    def _compile_binary_expression(self, expr: BinaryExpression) -> None:
        """Compile a binary expression."""
        # Compile left and right operands
        self._compile_expression(expr.left)
        self._compile_expression(expr.right)

        # Emit operation
        op = expr.operator

        if op == "+":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.ADD))
        elif op == "-":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.SUBTRACT))
        elif op == "*":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.MULTIPLY))
        elif op == "/":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.DIVIDE))
        elif op == "%":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.MODULO))
        elif op == "==":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.EQUAL))
        elif op == "!=":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.NOT_EQUAL))
        elif op == "<":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.LESS_THAN))
        elif op == "<=":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.LESS_EQUAL))
        elif op == ">":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.GREATER_THAN))
        elif op == ">=":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.GREATER_EQUAL))
        elif op == "=":
            # Assignment operator: x = value
            # Right side is already on stack from compilation above
            # Left side should be Identifier
            if hasattr(expr.left, "name"):
                var_name = expr.left.name
                # Duplicate value to keep on stack (assignment returns the value)
                self.bytecode.add_instruction(Instruction(opcode=Opcode.DUP))
                # Store in variable
                if var_name in self.locals:
                    local_index = self.locals[var_name]
                    self.bytecode.add_instruction(
                        Instruction(opcode=Opcode.STORE_LOCAL, operand1=local_index)
                    )
                else:
                    name_index = self.bytecode.add_constant(var_name)
                    self.bytecode.add_instruction(
                        Instruction(opcode=Opcode.STORE_GLOBAL, operand1=name_index)
                    )
            else:
                raise CompileError("Assignment to non-identifier not yet supported")
        else:
            raise CompileError(f"Unsupported binary operator: {op}")

    def _compile_pattern(self, pattern, keep_value=False):
        """
        Compile a destructuring pattern.

        Expands destructuring into individual assignments.
        Stack should have the value to destructure on top.

        Args:
            pattern: ObjectPattern, ArrayPattern, or Identifier
            keep_value: If True, keep the value on stack after destructuring
        """
        if isinstance(pattern, ObjectPattern):
            self._compile_object_pattern(pattern, keep_value)
        elif isinstance(pattern, ArrayPattern):
            self._compile_array_pattern(pattern, keep_value)
        elif isinstance(pattern, Identifier):
            # Simple identifier - allocate and store
            name = pattern.name
            if name not in self.locals:
                local_index = self.next_local_index
                self.locals[name] = local_index
                self.next_local_index += 1
            else:
                local_index = self.locals[name]

            if not keep_value:
                self.bytecode.add_instruction(
                    Instruction(opcode=Opcode.STORE_LOCAL, operand1=local_index)
                )
            else:
                # DUP and store
                self.bytecode.add_instruction(Instruction(opcode=Opcode.DUP))
                self.bytecode.add_instruction(
                    Instruction(opcode=Opcode.STORE_LOCAL, operand1=local_index)
                )
                self.bytecode.add_instruction(Instruction(opcode=Opcode.POP))
        else:
            raise CompileError(f"Unsupported pattern type: {type(pattern)}")

    def _compile_object_pattern(self, pattern: ObjectPattern, keep_value=False):
        """
        Compile object destructuring pattern.

        Strategy: const {x, y} = obj
        Compiles to:
        - obj is already on stack
        - DUP (keep obj for next property)
        - LOAD_CONST "x"
        - LOAD_PROPERTY
        - STORE_LOCAL x
        - DUP
        - LOAD_CONST "y"
        - LOAD_PROPERTY
        - STORE_LOCAL y
        - POP (remove obj)

        Args:
            pattern: ObjectPattern AST node
            keep_value: If True, keep the object on stack
        """
        properties = pattern.properties

        for i, prop in enumerate(properties):
            is_last = i == len(properties) - 1

            # Duplicate object for property access (unless last and not keeping)
            if not (is_last and not keep_value):
                self.bytecode.add_instruction(Instruction(opcode=Opcode.DUP))

            # Load property key
            if isinstance(prop.key, Identifier):
                const_index = self.bytecode.add_constant(prop.key.name)
                self.bytecode.add_instruction(
                    Instruction(opcode=Opcode.LOAD_CONSTANT, operand1=const_index)
                )
            else:
                # Computed property
                self._compile_expression(prop.key)

            # Load property value from object
            self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_PROPERTY))

            # Handle default value if present
            if isinstance(prop.value, AssignmentPattern):
                # Property has default: {x = 10}
                # Stack: [value]
                # Check if undefined, if so use default
                self._compile_assignment_pattern_default(prop.value)
                # Now compile the target (left side)
                self._compile_pattern_target(prop.value.left)
            else:
                # No default, compile target directly
                self._compile_pattern_target(prop.value)

        # If not keeping the original value, pop it
        if not keep_value:
            self.bytecode.add_instruction(Instruction(opcode=Opcode.POP))

    def _compile_array_pattern(self, pattern: ArrayPattern, keep_value=False):
        """
        Compile array destructuring pattern.

        Strategy: const [a, b] = arr
        Compiles to:
        - arr is already on stack
        - DUP (keep arr for next element)
        - LOAD_CONST 0
        - LOAD_ELEMENT
        - STORE_LOCAL a
        - DUP
        - LOAD_CONST 1
        - LOAD_ELEMENT
        - STORE_LOCAL b
        - POP (remove arr)

        Args:
            pattern: ArrayPattern AST node
            keep_value: If True, keep the array on stack
        """
        elements = pattern.elements
        index = 0

        for elem in elements:
            if elem is None:
                # Hole in array pattern: [a, , c]
                index += 1
                continue

            # Duplicate array for element access
            self.bytecode.add_instruction(Instruction(opcode=Opcode.DUP))

            # Load index
            const_index = self.bytecode.add_constant(index)
            self.bytecode.add_instruction(
                Instruction(opcode=Opcode.LOAD_CONSTANT, operand1=const_index)
            )

            # Load element from array
            self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_ELEMENT))

            # Handle default value if present
            if isinstance(elem, AssignmentPattern):
                # Element has default: [a = 5]
                self._compile_assignment_pattern_default(elem)
                self._compile_pattern_target(elem.left)
            else:
                # No default, compile target directly
                self._compile_pattern_target(elem)

            index += 1

        # If not keeping the original value, pop it
        if not keep_value:
            self.bytecode.add_instruction(Instruction(opcode=Opcode.POP))

    def _compile_pattern_target(self, target):
        """
        Compile the target of a destructuring pattern (what to assign to).

        Target can be:
        - Identifier: simple variable
        - ObjectPattern: nested object destructuring
        - ArrayPattern: nested array destructuring

        Stack: value to assign is on top
        """
        if isinstance(target, Identifier):
            # Allocate local if not exists
            name = target.name
            if name not in self.locals:
                local_index = self.next_local_index
                self.locals[name] = local_index
                self.next_local_index += 1
            else:
                local_index = self.locals[name]

            # Store to local
            self.bytecode.add_instruction(
                Instruction(opcode=Opcode.STORE_LOCAL, operand1=local_index)
            )
        elif isinstance(target, ObjectPattern):
            # Nested object destructuring
            self._compile_object_pattern(target, keep_value=False)
        elif isinstance(target, ArrayPattern):
            # Nested array destructuring
            self._compile_array_pattern(target, keep_value=False)
        else:
            raise CompileError(f"Unsupported pattern target: {type(target)}")

    def _compile_assignment_pattern_default(self, pattern: AssignmentPattern):
        """
        Compile default value handling for assignment pattern.

        Stack on entry: [value]
        Stack on exit: [value or default]

        If value is undefined, replace with default value.
        """
        # Duplicate value to check if undefined
        self.bytecode.add_instruction(Instruction(opcode=Opcode.DUP))

        # Load undefined for comparison
        self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_UNDEFINED))

        # Compare with ==
        self.bytecode.add_instruction(Instruction(opcode=Opcode.EQUAL))

        # If not undefined, jump over default value
        skip_default_label = len(self.bytecode.instructions) + 3
        self.bytecode.add_instruction(
            Instruction(opcode=Opcode.JUMP_IF_FALSE, operand1=skip_default_label)
        )

        # Value is undefined, pop it and use default
        self.bytecode.add_instruction(Instruction(opcode=Opcode.POP))
        self._compile_expression(pattern.right)

        # Skip_default label (value was not undefined, keep it)
        # No actual label instruction needed - JUMP_IF_FALSE jumps here

    def _compile_variable_declaration(self, decl: VariableDeclaration) -> None:
        """
        Compile a variable declaration (var, let, or const).

        Supports both simple identifiers and destructuring patterns.

        Phase 1: All declaration kinds (var/let/const) are compiled identically
        as function-scoped variables. This provides basic functionality without
        the complexity of lexical environments.

        Phase 2 TODO:
        - Add ENTER_BLOCK / EXIT_BLOCK opcodes for block scope tracking
        - Add DECLARE_LET / DECLARE_CONST opcodes (distinct from DECLARE_VAR)
        - Implement lexical environments in interpreter (scope chain)
        - Enforce TDZ (Temporal Dead Zone) for let/const
        - Prevent const reassignment at compile-time or runtime
        - Track scope depth for proper variable resolution

        Args:
            decl: VariableDeclaration AST node with kind ("var", "let", or "const")
        """
        # Phase 1: Treat all kinds the same (function-scoped)
        # kind = decl.kind  # "var", "let", or "const" - stored for future use

        for declarator in decl.declarations:
            # Check if declarator.id is a simple string or a destructuring pattern
            if isinstance(declarator.id, str):
                # Simple identifier: const x = value
                name = declarator.id

                # Allocate local variable
                # Phase 2 TODO: Allocate in appropriate scope (function vs block)
                local_index = self.next_local_index
                self.locals[name] = local_index
                self.next_local_index += 1

                # Compile initializer if present
                if declarator.init:
                    self._compile_expression(declarator.init)
                else:
                    # let/const without init â†’ undefined (const without init is parser error)
                    self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_UNDEFINED))

                # Store to local
                # Phase 2 TODO: Use different opcodes for let/const
                self.bytecode.add_instruction(
                    Instruction(opcode=Opcode.STORE_LOCAL, operand1=local_index)
                )
            else:
                # Destructuring pattern: const {x, y} = obj or const [a, b] = arr
                # Compile initializer first (must be present for destructuring)
                if declarator.init:
                    self._compile_expression(declarator.init)
                else:
                    # Destructuring without initializer - should be caught by parser
                    # but handle gracefully
                    self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_UNDEFINED))

                # Compile the destructuring pattern
                self._compile_pattern(declarator.id)

    def _compile_call_expression(self, expr: CallExpression) -> None:
        """Compile a function call expression."""
        # Compile callee
        self._compile_expression(expr.callee)

        # Compile arguments
        for arg in expr.arguments:
            self._compile_expression(arg)

        # Emit call with argument count
        arg_count = len(expr.arguments)
        self.bytecode.add_instruction(
            Instruction(opcode=Opcode.CALL_FUNCTION, operand1=arg_count)
        )

    def _compile_array_expression(self, expr: ArrayExpression) -> None:
        """
        Compile an array literal expression.

        Generates bytecode to create an array and populate it with elements.
        Array remains on stack after compilation.

        Args:
            expr: ArrayExpression AST node

        Bytecode sequence:
            CREATE_ARRAY          # Create empty array, push to stack
            For each element at index i:
                DUP               # Duplicate array reference
                LOAD_CONSTANT i   # Push index
                <element>         # Compile element expression
                STORE_ELEMENT     # Store element at index
        """
        # Create empty array
        self.bytecode.add_instruction(Instruction(opcode=Opcode.CREATE_ARRAY))

        # Add each element to the array
        for index, element in enumerate(expr.elements):
            # Duplicate array reference (so it stays on stack)
            self.bytecode.add_instruction(Instruction(opcode=Opcode.DUP))

            # Push index
            index_const = self.bytecode.add_constant(index)
            self.bytecode.add_instruction(
                Instruction(opcode=Opcode.LOAD_CONSTANT, operand1=index_const)
            )

            # Compile element expression (pushes value to stack)
            self._compile_expression(element)

            # Store element at index in array
            self.bytecode.add_instruction(Instruction(opcode=Opcode.STORE_ELEMENT))

    def _compile_object_expression(self, expr: ObjectExpression) -> None:
        """
        Compile an object literal expression.

        Generates bytecode to create an object and populate it with properties.
        Object remains on stack after compilation.

        Args:
            expr: ObjectExpression AST node

        Bytecode sequence:
            CREATE_OBJECT         # Create empty object, push to stack
            For each property:
                DUP               # Duplicate object reference
                <value>           # Compile value expression
                <key>             # Load or compute property key
                STORE_PROPERTY    # Store property in object
        """
        # Create empty object
        self.bytecode.add_instruction(Instruction(opcode=Opcode.CREATE_OBJECT))

        # Add each property to the object
        for prop in expr.properties:
            # Duplicate object reference (so it stays on stack)
            self.bytecode.add_instruction(Instruction(opcode=Opcode.DUP))

            # Compile property value
            self._compile_expression(prop.value)

            # Get property key
            if prop.computed:
                # Computed property: [expr]: value
                # Compile the key expression
                self._compile_expression(prop.key)
            else:
                # Normal property: key: value or shorthand {key}
                # Extract key name from Identifier or Literal
                if isinstance(prop.key, Identifier):
                    key_name = prop.key.name
                elif isinstance(prop.key, Literal):
                    key_name = str(prop.key.value)
                else:
                    raise CompileError(
                        f"Unsupported property key type: {type(prop.key).__name__}"
                    )

                # Load key as constant
                key_index = self.bytecode.add_constant(key_name)
                self.bytecode.add_instruction(
                    Instruction(opcode=Opcode.LOAD_CONSTANT, operand1=key_index)
                )

            # Store property in object
            self.bytecode.add_instruction(Instruction(opcode=Opcode.STORE_PROPERTY))

    def _compile_arrow_function_expression(self, node: ArrowFunctionExpression) -> None:
        """
        Compile an arrow function expression.

        Arrow functions are anonymous functions with concise syntax. They support
        two body forms:
        - Expression body: x => x * 2 (implicit return)
        - Block body: x => { return x * 2; } (explicit return)

        Args:
            node: ArrowFunctionExpression AST node

        Bytecode sequence:
            CREATE_FUNCTION param_count, function_bytecode

        The function bytecode contains:
            For expression body:
                <expression bytecode>
                RETURN
            For block body:
                <block bytecode>
                LOAD_UNDEFINED  # Implicit return if no explicit return
                RETURN
        """
        # Extract parameter names
        param_names = [param.name for param in node.params]
        param_count = len(param_names)

        # Save current bytecode context
        saved_bytecode = self.bytecode
        saved_locals = self.locals.copy()
        saved_next_local_index = self.next_local_index

        # Create new bytecode for function body
        self.bytecode = BytecodeArray(local_count=param_count)
        self.locals = {}
        self.next_local_index = 0

        # Declare parameters as local variables
        for param_name in param_names:
            local_index = self.next_local_index
            self.locals[param_name] = local_index
            self.next_local_index += 1

        # Compile function body based on type
        if isinstance(node.body, BlockStatement):
            # Block body: compile statements normally
            for statement in node.body.body:
                self._compile_statement(statement)

            # Add implicit return undefined at end (in case no explicit return)
            self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_UNDEFINED))
            self.bytecode.add_instruction(Instruction(opcode=Opcode.RETURN))
        else:
            # Expression body: compile expression and add implicit return
            self._compile_expression(node.body)
            self.bytecode.add_instruction(Instruction(opcode=Opcode.RETURN))

        # Get compiled function bytecode
        function_bytecode = self.bytecode

        # Set local count for function
        function_bytecode.local_count = self.next_local_index

        # Restore parent context
        self.bytecode = saved_bytecode
        self.locals = saved_locals
        self.next_local_index = saved_next_local_index

        # Emit CREATE_CLOSURE instruction
        # operand1: parameter count
        # operand2: function bytecode
        self.bytecode.add_instruction(
            Instruction(
                opcode=Opcode.CREATE_CLOSURE,
                operand1=param_count,
                operand2=function_bytecode,
            )
        )

    def _compile_function_declaration(self, node: FunctionDeclaration) -> None:
        """
        Compile a function declaration.

        Function declarations create a function and store it in a variable
        with the function's name. Unlike arrow functions, they have a name
        and must be stored as a variable.

        Example:
            function add(a, b) { return a + b; }

        Compiles to:
            CREATE_CLOSURE param_count, function_bytecode
            STORE_GLOBAL "add"  (or STORE_LOCAL if in function scope)

        Args:
            node: FunctionDeclaration AST node
        """
        # Extract function details
        function_name = node.name
        param_names = node.parameters
        param_count = len(param_names)
        function_body = node.body

        # Save current bytecode context
        saved_bytecode = self.bytecode
        saved_locals = self.locals.copy()
        saved_next_local_index = self.next_local_index

        # Create new bytecode for function body
        self.bytecode = BytecodeArray(local_count=param_count)
        self.locals = {}
        self.next_local_index = 0

        # Declare parameters as local variables
        for param_name in param_names:
            local_index = self.next_local_index
            self.locals[param_name] = local_index
            self.next_local_index += 1

        # Compile function body (always a BlockStatement)
        for statement in function_body.body:
            self._compile_statement(statement)

        # Add implicit return undefined at end (in case no explicit return)
        self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_UNDEFINED))
        self.bytecode.add_instruction(Instruction(opcode=Opcode.RETURN))

        # Get compiled function bytecode
        function_bytecode = self.bytecode

        # Set local count for function
        function_bytecode.local_count = self.next_local_index

        # Restore parent context
        self.bytecode = saved_bytecode
        self.locals = saved_locals
        self.next_local_index = saved_next_local_index

        # Emit CREATE_CLOSURE instruction to create the function
        self.bytecode.add_instruction(
            Instruction(
                opcode=Opcode.CREATE_CLOSURE,
                operand1=param_count,
                operand2=function_bytecode,
            )
        )

        # CRITICAL FIX: Store the function in a variable with its name
        # This makes the function accessible for later calls
        if function_name in self.locals:
            # Function declared inside another function - use local storage
            local_index = self.locals[function_name]
            self.bytecode.add_instruction(
                Instruction(opcode=Opcode.STORE_LOCAL, operand1=local_index)
            )
        else:
            # Function declared at top level - use global storage
            name_index = self.bytecode.add_constant(function_name)
            self.bytecode.add_instruction(
                Instruction(opcode=Opcode.STORE_GLOBAL, operand1=name_index)
            )

    def _compile_member_expression(self, node: MemberExpression) -> None:
        """
        Compile a member expression (property access).

        Member expressions represent property access on objects.
        Two forms:
        - obj.property (computed=False): Direct property access
        - obj[expr] (computed=True): Computed property access

        Args:
            node: MemberExpression AST node

        Bytecode sequence for obj.property:
            <compile obj>          # Evaluate object expression
            LOAD_PROPERTY "property"  # Get property from object

        Bytecode sequence for obj[expr]:
            <compile obj>          # Evaluate object expression
            <compile expr>         # Evaluate property expression
            LOAD_ELEMENT           # Get element from object
        """
        # Compile object (e.g., identifier 'obj')
        self._compile_expression(node.object)

        # Compile property access
        if node.computed:
            # obj[expr] - computed property
            self._compile_expression(node.property)
            self._emit(Opcode.LOAD_ELEMENT)
        else:
            # obj.property - direct property
            property_name = node.property.name
            property_index = self.bytecode.add_constant(property_name)
            self._emit(Opcode.LOAD_PROPERTY, property_index)

    def _compile_template_literal(self, node: TemplateLiteral) -> None:
        """
        Compile a template literal to bytecode.

        Template literals are compiled to a series of string concatenation
        operations using the ADD opcode. Each quasi (static text) is loaded
        as a constant, and each expression is compiled normally. The parts
        are then concatenated left-to-right.

        Args:
            node: TemplateLiteral AST node

        Example bytecode for `Hello ${name}!`:
            LOAD_CONSTANT "Hello "
            LOAD_GLOBAL "name"
            ADD
            LOAD_CONSTANT "!"
            ADD
        """
        # Handle empty template literal
        if len(node.quasis) == 1 and len(node.expressions) == 0:
            # Just a single static string
            const_index = self.bytecode.add_constant(node.quasis[0])
            self._emit(Opcode.LOAD_CONSTANT, const_index)
            return

        # Build the result by concatenating all parts
        # quasis[0] expr[0] quasis[1] expr[1] ... quasis[n]
        # where len(quasis) = len(expressions) + 1

        # Load first quasi
        const_index = self.bytecode.add_constant(node.quasis[0])
        self._emit(Opcode.LOAD_CONSTANT, const_index)

        # Interleave expressions and quasis
        for i, expression in enumerate(node.expressions):
            # Compile the expression
            self._compile_expression(expression)

            # Add (concatenate)
            self._emit(Opcode.ADD)

            # Load the next quasi (if not empty)
            next_quasi = node.quasis[i + 1]
            if next_quasi:  # Only if quasi is not empty string
                const_index = self.bytecode.add_constant(next_quasi)
                self._emit(Opcode.LOAD_CONSTANT, const_index)
                self._emit(Opcode.ADD)

    def _compile_if_statement(self, node: IfStatement) -> None:
        """
        Compile an if statement.

        If statements conditionally execute code based on a test expression.

        Args:
            node: IfStatement AST node

        Bytecode sequence without else:
            <compile condition>
            JUMP_IF_FALSE :end_label
            <compile consequent>
            :end_label

        Bytecode sequence with else:
            <compile condition>
            JUMP_IF_FALSE :else_label
            <compile consequent>
            JUMP :end_label
            :else_label
            <compile alternate>
            :end_label
        """
        # Compile condition
        self._compile_expression(node.test)

        # Reserve slot for JUMP_IF_FALSE (we'll patch it later)
        jump_to_else = len(self.bytecode.instructions)
        self._emit(Opcode.JUMP_IF_FALSE, 0)  # Placeholder

        # Compile consequent (then branch)
        self._compile_statement(node.consequent)

        if node.alternate:
            # Reserve slot for JUMP over else
            jump_to_end = len(self.bytecode.instructions)
            self._emit(Opcode.JUMP, 0)  # Placeholder

            # Patch JUMP_IF_FALSE to point here (start of else)
            else_start = len(self.bytecode.instructions)
            self.bytecode.instructions[jump_to_else].operand1 = else_start

            # Compile alternate (else branch)
            self._compile_statement(node.alternate)

            # Patch JUMP to point here (end)
            end_label = len(self.bytecode.instructions)
            self.bytecode.instructions[jump_to_end].operand1 = end_label
        else:
            # No else branch - patch JUMP_IF_FALSE to point to end
            end_label = len(self.bytecode.instructions)
            self.bytecode.instructions[jump_to_else].operand1 = end_label

    def _compile_while_statement(self, node: WhileStatement) -> None:
        """
        Compile a while statement.

        While statements repeatedly execute code while a condition is true.

        Args:
            node: WhileStatement AST node

        Bytecode sequence:
            :loop_start
            <compile condition>
            JUMP_IF_FALSE :loop_end
            <compile body>
            JUMP :loop_start
            :loop_end
        """
        # Mark loop start
        loop_start = len(self.bytecode.instructions)

        # Compile condition
        self._compile_expression(node.test)

        # Reserve slot for JUMP_IF_FALSE to end
        jump_to_end = len(self.bytecode.instructions)
        self._emit(Opcode.JUMP_IF_FALSE, 0)  # Placeholder

        # Compile body
        self._compile_statement(node.body)

        # Jump back to loop start
        self._emit(Opcode.JUMP, loop_start)

        # Patch JUMP_IF_FALSE to point here (loop end)
        loop_end = len(self.bytecode.instructions)
        self.bytecode.instructions[jump_to_end].operand1 = loop_end

    def _compile_for_statement(self, node: ForStatement) -> None:
        """
        Compile a traditional for loop statement.

        Traditional for loops have init, test, and update clauses.
        Example: for (var i = 0; i < 10; i++) { ... }

        Args:
            node: ForStatement AST node

        Bytecode sequence:
            <compile init>
            :loop_start
            <compile test>
            JUMP_IF_FALSE :loop_end
            <compile body>
            :continue_target
            <compile update>
            JUMP :loop_start
            :loop_end
        """
        # Compile initialization (if present)
        if node.init:
            if isinstance(node.init, VariableDeclaration):
                self._compile_variable_declaration(node.init)
            else:
                # Expression init (e.g., i = 0)
                self._compile_expression(node.init)
                # Pop the result since we don't need it
                self._emit(Opcode.POP)

        # Mark loop start (where test happens)
        loop_start = len(self.bytecode.instructions)

        # Compile test condition (if present)
        jump_to_end = None
        if node.test:
            self._compile_expression(node.test)
            # Reserve slot for JUMP_IF_FALSE to end
            jump_to_end = len(self.bytecode.instructions)
            self._emit(Opcode.JUMP_IF_FALSE, 0)  # Placeholder

        # Compile body
        self._compile_statement(node.body)

        # Compile update (if present)
        if node.update:
            self._compile_expression(node.update)
            # Pop the result
            self._emit(Opcode.POP)

        # Jump back to loop start
        self._emit(Opcode.JUMP, loop_start)

        # Patch JUMP_IF_FALSE to point here (loop end)
        loop_end = len(self.bytecode.instructions)
        if jump_to_end is not None:
            self.bytecode.instructions[jump_to_end].operand1 = loop_end

    def _compile_for_in_statement(self, node: ForInStatement) -> None:
        """
        Compile a for-in loop statement.

        For-in loops iterate over object properties (keys).
        Example: for (var key in obj) { ... }

        Args:
            node: ForInStatement AST node

        Bytecode sequence:
            <compile object>
            CREATE_ARRAY              # Convert keys to array (simplified)
            LOAD_CONSTANT 0           # Initialize counter
            STORE_LOCAL counter_idx   # Store counter
            :loop_start
            LOAD_LOCAL counter_idx    # Load counter
            LOAD_LOCAL keys_idx       # Load keys array
            LOAD_PROPERTY "length"    # Get array length
            LESS_THAN                 # counter < length?
            JUMP_IF_FALSE :loop_end
            LOAD_LOCAL keys_idx       # Load keys array
            LOAD_LOCAL counter_idx    # Load counter
            LOAD_ELEMENT              # Get key at counter
            <store in loop variable>  # Store key in loop var
            <compile body>
            LOAD_LOCAL counter_idx    # Load counter
            LOAD_CONSTANT 1           # Load 1
            ADD                       # Increment
            STORE_LOCAL counter_idx   # Store counter
            JUMP :loop_start
            :loop_end
        """
        # For Phase 1, implement simplified version using existing opcodes
        # In a full implementation, we'd need Object.keys() or a GET_KEYS opcode

        # Compile the object/expression to iterate over
        self._compile_expression(node.right)

        # For now, we'll create a simplified implementation:
        # Store object in a temporary local
        obj_local = self.next_local_index
        self.next_local_index += 1
        self._emit(Opcode.STORE_LOCAL, obj_local)

        # Create counter variable (starts at 0)
        counter_local = self.next_local_index
        self.next_local_index += 1
        self._emit(Opcode.LOAD_CONSTANT, self.bytecode.add_constant(0))
        self._emit(Opcode.STORE_LOCAL, counter_local)

        # Declare/get the loop variable
        if isinstance(node.left, VariableDeclaration):
            # var key in obj - declare new variable
            var_name = node.left.declarations[0].name
            loop_var_local = self.next_local_index
            self.locals[var_name] = loop_var_local
            self.next_local_index += 1
        else:
            # Existing identifier
            var_name = node.left.name
            if var_name in self.locals:
                loop_var_local = self.locals[var_name]
            else:
                # Create global reference (simplified)
                loop_var_local = self.next_local_index
                self.locals[var_name] = loop_var_local
                self.next_local_index += 1

        # Mark loop start
        loop_start = len(self.bytecode.instructions)

        # For simplified implementation, we'll create a fixed iteration count
        # In full implementation, we'd iterate over actual object keys
        # Load counter
        self._emit(Opcode.LOAD_LOCAL, counter_local)
        # Load max iterations (using a constant for now - in real impl, would be key count)
        self._emit(Opcode.LOAD_CONSTANT, self.bytecode.add_constant(10))  # Placeholder
        # Check if counter < max
        self._emit(Opcode.LESS_THAN)

        # Jump to end if false
        jump_to_end = len(self.bytecode.instructions)
        self._emit(Opcode.JUMP_IF_FALSE, 0)  # Placeholder

        # Load a placeholder key value (in real impl, would get actual key from object)
        # For now, just use the counter value as the "key"
        self._emit(Opcode.LOAD_LOCAL, counter_local)
        self._emit(Opcode.STORE_LOCAL, loop_var_local)

        # Compile loop body
        self._compile_statement(node.body)

        # Increment counter
        self._emit(Opcode.LOAD_LOCAL, counter_local)
        self._emit(Opcode.LOAD_CONSTANT, self.bytecode.add_constant(1))
        self._emit(Opcode.ADD)
        self._emit(Opcode.STORE_LOCAL, counter_local)

        # Jump back to loop start
        self._emit(Opcode.JUMP, loop_start)

        # Patch JUMP_IF_FALSE to point here (loop end)
        loop_end = len(self.bytecode.instructions)
        self.bytecode.instructions[jump_to_end].operand1 = loop_end

    def _compile_for_of_statement(self, node: ForOfStatement) -> None:
        """
        Compile a for-of loop statement.

        For-of loops iterate over iterable objects (array elements).
        Example: for (var value of array) { ... }

        Args:
            node: ForOfStatement AST node

        Bytecode sequence:
            <compile iterable>
            STORE_LOCAL iterable_idx
            LOAD_CONSTANT 0           # Initialize counter
            STORE_LOCAL counter_idx   # Store counter
            :loop_start
            LOAD_LOCAL counter_idx    # Load counter
            LOAD_LOCAL iterable_idx   # Load array
            LOAD_PROPERTY "length"    # Get array length
            LESS_THAN                 # counter < length?
            JUMP_IF_FALSE :loop_end
            LOAD_LOCAL iterable_idx   # Load array
            LOAD_LOCAL counter_idx    # Load counter
            LOAD_ELEMENT              # Get element at counter
            <store in loop variable>  # Store value in loop var
            <compile body>
            LOAD_LOCAL counter_idx    # Load counter
            LOAD_CONSTANT 1           # Load 1
            ADD                       # Increment
            STORE_LOCAL counter_idx   # Store counter
            JUMP :loop_start
            :loop_end
        """
        # Compile the iterable (array) to iterate over
        self._compile_expression(node.right)

        # Store iterable in a temporary local
        iterable_local = self.next_local_index
        self.next_local_index += 1
        self._emit(Opcode.STORE_LOCAL, iterable_local)

        # Create counter variable (starts at 0)
        counter_local = self.next_local_index
        self.next_local_index += 1
        self._emit(Opcode.LOAD_CONSTANT, self.bytecode.add_constant(0))
        self._emit(Opcode.STORE_LOCAL, counter_local)

        # Declare/get the loop variable
        if isinstance(node.left, VariableDeclaration):
            # var value of array - declare new variable
            var_name = node.left.declarations[0].name
            loop_var_local = self.next_local_index
            self.locals[var_name] = loop_var_local
            self.next_local_index += 1
        else:
            # Existing identifier
            var_name = node.left.name
            if var_name in self.locals:
                loop_var_local = self.locals[var_name]
            else:
                # Create local reference
                loop_var_local = self.next_local_index
                self.locals[var_name] = loop_var_local
                self.next_local_index += 1

        # Mark loop start
        loop_start = len(self.bytecode.instructions)

        # Load counter
        self._emit(Opcode.LOAD_LOCAL, counter_local)
        # Load iterable and get length
        self._emit(Opcode.LOAD_LOCAL, iterable_local)
        length_const = self.bytecode.add_constant("length")
        self._emit(Opcode.LOAD_PROPERTY, length_const)
        # Check if counter < length
        self._emit(Opcode.LESS_THAN)

        # Jump to end if false
        jump_to_end = len(self.bytecode.instructions)
        self._emit(Opcode.JUMP_IF_FALSE, 0)  # Placeholder

        # Get element at current index
        self._emit(Opcode.LOAD_LOCAL, iterable_local)
        self._emit(Opcode.LOAD_LOCAL, counter_local)
        self._emit(Opcode.LOAD_ELEMENT)

        # Store in loop variable
        self._emit(Opcode.STORE_LOCAL, loop_var_local)

        # Compile loop body
        self._compile_statement(node.body)

        # Increment counter
        self._emit(Opcode.LOAD_LOCAL, counter_local)
        self._emit(Opcode.LOAD_CONSTANT, self.bytecode.add_constant(1))
        self._emit(Opcode.ADD)
        self._emit(Opcode.STORE_LOCAL, counter_local)

        # Jump back to loop start
        self._emit(Opcode.JUMP, loop_start)

        # Patch JUMP_IF_FALSE to point here (loop end)
        loop_end = len(self.bytecode.instructions)
        self.bytecode.instructions[jump_to_end].operand1 = loop_end

    def _emit(self, opcode: Opcode, operand1=None, operand2=None) -> None:
        """
        Helper method to emit an instruction.

        Args:
            opcode: The opcode to emit
            operand1: First operand (optional)
            operand2: Second operand (optional)
        """
        self.bytecode.add_instruction(
            Instruction(opcode=opcode, operand1=operand1, operand2=operand2)
        )
