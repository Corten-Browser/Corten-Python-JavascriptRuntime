"""
Bytecode compiler - compiles AST to bytecode.

This module provides the BytecodeCompiler class which traverses a JavaScript
AST and generates bytecode instructions.

Public API:
    - BytecodeCompiler: AST to bytecode compiler
    - CompileError: Compilation error exception
"""

from typing import Dict, Optional

from .opcode import Opcode
from .instruction import Instruction
from .bytecode_array import BytecodeArray

from components.parser.src.ast_nodes import (
    Program,
    Expression,
    Statement,
    Literal,
    Identifier,
    BinaryExpression,
    ExpressionStatement,
    VariableDeclaration,
    ReturnStatement,
    FunctionDeclaration,
    CallExpression,
)


class CompileError(Exception):
    """Exception raised during bytecode compilation."""

    pass


class BytecodeCompiler:
    """
    Compiles JavaScript AST to bytecode.

    This class traverses an Abstract Syntax Tree (AST) and generates
    bytecode instructions for execution by the virtual machine.

    Attributes:
        ast: The Program AST node to compile
        bytecode: The generated bytecode array

    Example:
        >>> from components.parser.src import Parse
        >>> from components.bytecode.src.compiler import BytecodeCompiler
        >>>
        >>> ast = Parse("var x = 42;")
        >>> compiler = BytecodeCompiler(ast)
        >>> bytecode = compiler.compile()
        >>> len(bytecode.instructions) > 0
        True
    """

    def __init__(self, ast: Program):
        """
        Initialize BytecodeCompiler with AST.

        Args:
            ast: Program AST node to compile
        """
        self.ast = ast
        self.bytecode = BytecodeArray()
        self.locals: Dict[str, int] = {}  # variable name -> local index
        self.next_local_index = 0

    def compile(self) -> BytecodeArray:
        """
        Compile AST to bytecode.

        Traverses the AST and generates bytecode instructions.

        Returns:
            BytecodeArray containing compiled bytecode

        Raises:
            CompileError: If compilation fails

        Example:
            >>> from components.parser.src.ast_nodes import Program
            >>> from components.bytecode.src.compiler import BytecodeCompiler
            >>>
            >>> ast = Program(body=[])
            >>> compiler = BytecodeCompiler(ast)
            >>> bytecode = compiler.compile()
            >>> len(bytecode.instructions) >= 1
            True
        """
        try:
            # Compile program body
            for statement in self.ast.body:
                self._compile_statement(statement)

            # Add implicit return at end
            self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_UNDEFINED))
            self.bytecode.add_instruction(Instruction(opcode=Opcode.RETURN))

            # Set local count
            self.bytecode.local_count = self.next_local_index

            return self.bytecode

        except Exception as e:
            raise CompileError(f"Compilation failed: {e}") from e

    def _compile_statement(self, stmt: Statement) -> None:
        """Compile a statement node."""
        if isinstance(stmt, ExpressionStatement):
            self._compile_expression(stmt.expression)
            # Pop expression result (statement doesn't use it)
            self.bytecode.add_instruction(Instruction(opcode=Opcode.POP))

        elif isinstance(stmt, VariableDeclaration):
            self._compile_variable_declaration(stmt)

        elif isinstance(stmt, ReturnStatement):
            if stmt.argument:
                self._compile_expression(stmt.argument)
            else:
                self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_UNDEFINED))
            self.bytecode.add_instruction(Instruction(opcode=Opcode.RETURN))

        elif isinstance(stmt, FunctionDeclaration):
            # Simplified: Skip function declarations for now
            pass

        else:
            raise CompileError(f"Unsupported statement type: {type(stmt).__name__}")

    def _compile_expression(self, expr: Expression) -> None:
        """Compile an expression node."""
        if isinstance(expr, Literal):
            self._compile_literal(expr)

        elif isinstance(expr, Identifier):
            self._compile_identifier(expr)

        elif isinstance(expr, BinaryExpression):
            self._compile_binary_expression(expr)

        elif isinstance(expr, CallExpression):
            # Simplified: Basic function call
            self._compile_call_expression(expr)

        else:
            raise CompileError(f"Unsupported expression type: {type(expr).__name__}")

    def _compile_literal(self, lit: Literal) -> None:
        """Compile a literal value."""
        value = lit.value

        if value is None:
            self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_NULL))
        elif value is True:
            self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_TRUE))
        elif value is False:
            self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_FALSE))
        else:
            # Add to constant pool and emit LOAD_CONSTANT
            const_index = self.bytecode.add_constant(value)
            self.bytecode.add_instruction(
                Instruction(opcode=Opcode.LOAD_CONSTANT, operand1=const_index)
            )

    def _compile_identifier(self, ident: Identifier) -> None:
        """Compile an identifier (variable reference)."""
        name = ident.name

        # Check if it's a local variable
        if name in self.locals:
            local_index = self.locals[name]
            self.bytecode.add_instruction(
                Instruction(opcode=Opcode.LOAD_LOCAL, operand1=local_index)
            )
        else:
            # Treat as global
            name_index = self.bytecode.add_constant(name)
            self.bytecode.add_instruction(
                Instruction(opcode=Opcode.LOAD_GLOBAL, operand1=name_index)
            )

    def _compile_binary_expression(self, expr: BinaryExpression) -> None:
        """Compile a binary expression."""
        # Compile left and right operands
        self._compile_expression(expr.left)
        self._compile_expression(expr.right)

        # Emit operation
        op = expr.operator

        if op == "+":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.ADD))
        elif op == "-":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.SUBTRACT))
        elif op == "*":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.MULTIPLY))
        elif op == "/":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.DIVIDE))
        elif op == "%":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.MODULO))
        elif op == "==":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.EQUAL))
        elif op == "!=":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.NOT_EQUAL))
        elif op == "<":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.LESS_THAN))
        elif op == "<=":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.LESS_EQUAL))
        elif op == ">":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.GREATER_THAN))
        elif op == ">=":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.GREATER_EQUAL))
        else:
            raise CompileError(f"Unsupported binary operator: {op}")

    def _compile_variable_declaration(self, decl: VariableDeclaration) -> None:
        """Compile a variable declaration."""
        for declarator in decl.declarations:
            name = declarator.name

            # Allocate local variable
            local_index = self.next_local_index
            self.locals[name] = local_index
            self.next_local_index += 1

            # Compile initializer if present
            if declarator.init:
                self._compile_expression(declarator.init)
            else:
                self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_UNDEFINED))

            # Store to local
            self.bytecode.add_instruction(
                Instruction(opcode=Opcode.STORE_LOCAL, operand1=local_index)
            )

    def _compile_call_expression(self, expr: CallExpression) -> None:
        """Compile a function call expression."""
        # Compile callee
        self._compile_expression(expr.callee)

        # Compile arguments
        for arg in expr.arguments:
            self._compile_expression(arg)

        # Emit call with argument count
        arg_count = len(expr.arguments)
        self.bytecode.add_instruction(
            Instruction(opcode=Opcode.CALL_FUNCTION, operand1=arg_count)
        )
