"""
Bytecode compiler - compiles AST to bytecode.

This module provides the BytecodeCompiler class which traverses a JavaScript
AST and generates bytecode instructions.

Public API:
    - BytecodeCompiler: AST to bytecode compiler
    - CompileError: Compilation error exception
"""

from typing import Dict

from .opcode import Opcode
from .instruction import Instruction
from .bytecode_array import BytecodeArray

from components.parser.src.ast_nodes import (
    Program,
    Expression,
    Statement,
    Literal,
    Identifier,
    BinaryExpression,
    ExpressionStatement,
    VariableDeclaration,
    ReturnStatement,
    FunctionDeclaration,
    CallExpression,
    ArrayExpression,
    ObjectExpression,
    Property,
    ArrowFunctionExpression,
    BlockStatement,
)


class CompileError(Exception):
    """Exception raised during bytecode compilation."""

    pass


class BytecodeCompiler:
    """
    Compiles JavaScript AST to bytecode.

    This class traverses an Abstract Syntax Tree (AST) and generates
    bytecode instructions for execution by the virtual machine.

    Attributes:
        ast: The Program AST node to compile
        bytecode: The generated bytecode array

    Example:
        >>> from components.parser.src import Parse
        >>> from components.bytecode.src.compiler import BytecodeCompiler
        >>>
        >>> ast = Parse("var x = 42;")
        >>> compiler = BytecodeCompiler(ast)
        >>> bytecode = compiler.compile()
        >>> len(bytecode.instructions) > 0
        True
    """

    def __init__(self, ast: Program):
        """
        Initialize BytecodeCompiler with AST.

        Args:
            ast: Program AST node to compile
        """
        self.ast = ast
        self.bytecode = BytecodeArray()
        self.locals: Dict[str, int] = {}  # variable name -> local index
        self.next_local_index = 0

    def compile(self) -> BytecodeArray:
        """
        Compile AST to bytecode.

        Traverses the AST and generates bytecode instructions.

        Returns:
            BytecodeArray containing compiled bytecode

        Raises:
            CompileError: If compilation fails

        Example:
            >>> from components.parser.src.ast_nodes import Program
            >>> from components.bytecode.src.compiler import BytecodeCompiler
            >>>
            >>> ast = Program(body=[])
            >>> compiler = BytecodeCompiler(ast)
            >>> bytecode = compiler.compile()
            >>> len(bytecode.instructions) >= 1
            True
        """
        try:
            # Compile program body
            for statement in self.ast.body:
                self._compile_statement(statement)

            # Add implicit return at end
            self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_UNDEFINED))
            self.bytecode.add_instruction(Instruction(opcode=Opcode.RETURN))

            # Set local count
            self.bytecode.local_count = self.next_local_index

            return self.bytecode

        except Exception as e:
            raise CompileError(f"Compilation failed: {e}") from e

    def _compile_statement(self, stmt: Statement) -> None:
        """Compile a statement node."""
        if isinstance(stmt, ExpressionStatement):
            self._compile_expression(stmt.expression)
            # Pop expression result (statement doesn't use it)
            self.bytecode.add_instruction(Instruction(opcode=Opcode.POP))

        elif isinstance(stmt, VariableDeclaration):
            self._compile_variable_declaration(stmt)

        elif isinstance(stmt, ReturnStatement):
            if stmt.argument:
                self._compile_expression(stmt.argument)
            else:
                self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_UNDEFINED))
            self.bytecode.add_instruction(Instruction(opcode=Opcode.RETURN))

        elif isinstance(stmt, FunctionDeclaration):
            self._compile_function_declaration(stmt)

        else:
            raise CompileError(f"Unsupported statement type: {type(stmt).__name__}")

    def _compile_expression(self, expr: Expression) -> None:
        """Compile an expression node."""
        if isinstance(expr, Literal):
            self._compile_literal(expr)

        elif isinstance(expr, Identifier):
            self._compile_identifier(expr)

        elif isinstance(expr, BinaryExpression):
            self._compile_binary_expression(expr)

        elif isinstance(expr, CallExpression):
            # Simplified: Basic function call
            self._compile_call_expression(expr)

        elif isinstance(expr, ArrayExpression):
            self._compile_array_expression(expr)

        elif isinstance(expr, ObjectExpression):
            self._compile_object_expression(expr)

        elif isinstance(expr, ArrowFunctionExpression):
            self._compile_arrow_function_expression(expr)

        else:
            raise CompileError(f"Unsupported expression type: {type(expr).__name__}")

    def _compile_literal(self, lit: Literal) -> None:
        """Compile a literal value."""
        value = lit.value

        if value is None:
            self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_NULL))
        elif value is True:
            self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_TRUE))
        elif value is False:
            self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_FALSE))
        else:
            # Add to constant pool and emit LOAD_CONSTANT
            const_index = self.bytecode.add_constant(value)
            self.bytecode.add_instruction(
                Instruction(opcode=Opcode.LOAD_CONSTANT, operand1=const_index)
            )

    def _compile_identifier(self, ident: Identifier) -> None:
        """Compile an identifier (variable reference)."""
        name = ident.name

        # Check if it's a local variable
        if name in self.locals:
            local_index = self.locals[name]
            self.bytecode.add_instruction(
                Instruction(opcode=Opcode.LOAD_LOCAL, operand1=local_index)
            )
        else:
            # Treat as global
            name_index = self.bytecode.add_constant(name)
            self.bytecode.add_instruction(
                Instruction(opcode=Opcode.LOAD_GLOBAL, operand1=name_index)
            )

    def _compile_binary_expression(self, expr: BinaryExpression) -> None:
        """Compile a binary expression."""
        # Compile left and right operands
        self._compile_expression(expr.left)
        self._compile_expression(expr.right)

        # Emit operation
        op = expr.operator

        if op == "+":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.ADD))
        elif op == "-":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.SUBTRACT))
        elif op == "*":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.MULTIPLY))
        elif op == "/":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.DIVIDE))
        elif op == "%":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.MODULO))
        elif op == "==":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.EQUAL))
        elif op == "!=":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.NOT_EQUAL))
        elif op == "<":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.LESS_THAN))
        elif op == "<=":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.LESS_EQUAL))
        elif op == ">":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.GREATER_THAN))
        elif op == ">=":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.GREATER_EQUAL))
        else:
            raise CompileError(f"Unsupported binary operator: {op}")

    def _compile_variable_declaration(self, decl: VariableDeclaration) -> None:
        """
        Compile a variable declaration (var, let, or const).

        Phase 1: All declaration kinds (var/let/const) are compiled identically
        as function-scoped variables. This provides basic functionality without
        the complexity of lexical environments.

        Phase 2 TODO:
        - Add ENTER_BLOCK / EXIT_BLOCK opcodes for block scope tracking
        - Add DECLARE_LET / DECLARE_CONST opcodes (distinct from DECLARE_VAR)
        - Implement lexical environments in interpreter (scope chain)
        - Enforce TDZ (Temporal Dead Zone) for let/const
        - Prevent const reassignment at compile-time or runtime
        - Track scope depth for proper variable resolution

        Args:
            decl: VariableDeclaration AST node with kind ("var", "let", or "const")
        """
        # Phase 1: Treat all kinds the same (function-scoped)
        # kind = decl.kind  # "var", "let", or "const" - stored for future use

        for declarator in decl.declarations:
            name = declarator.name

            # Allocate local variable
            # Phase 2 TODO: Allocate in appropriate scope (function vs block)
            local_index = self.next_local_index
            self.locals[name] = local_index
            self.next_local_index += 1

            # Compile initializer if present
            if declarator.init:
                self._compile_expression(declarator.init)
            else:
                # let/const without init â†’ undefined (const without init is parser error)
                self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_UNDEFINED))

            # Store to local
            # Phase 2 TODO: Use different opcodes for let/const
            self.bytecode.add_instruction(
                Instruction(opcode=Opcode.STORE_LOCAL, operand1=local_index)
            )

    def _compile_call_expression(self, expr: CallExpression) -> None:
        """Compile a function call expression."""
        # Compile callee
        self._compile_expression(expr.callee)

        # Compile arguments
        for arg in expr.arguments:
            self._compile_expression(arg)

        # Emit call with argument count
        arg_count = len(expr.arguments)
        self.bytecode.add_instruction(
            Instruction(opcode=Opcode.CALL_FUNCTION, operand1=arg_count)
        )

    def _compile_array_expression(self, expr: ArrayExpression) -> None:
        """
        Compile an array literal expression.

        Generates bytecode to create an array and populate it with elements.
        Array remains on stack after compilation.

        Args:
            expr: ArrayExpression AST node

        Bytecode sequence:
            CREATE_ARRAY          # Create empty array, push to stack
            For each element at index i:
                DUP               # Duplicate array reference
                LOAD_CONSTANT i   # Push index
                <element>         # Compile element expression
                STORE_ELEMENT     # Store element at index
        """
        # Create empty array
        self.bytecode.add_instruction(Instruction(opcode=Opcode.CREATE_ARRAY))

        # Add each element to the array
        for index, element in enumerate(expr.elements):
            # Duplicate array reference (so it stays on stack)
            self.bytecode.add_instruction(Instruction(opcode=Opcode.DUP))

            # Push index
            index_const = self.bytecode.add_constant(index)
            self.bytecode.add_instruction(
                Instruction(opcode=Opcode.LOAD_CONSTANT, operand1=index_const)
            )

            # Compile element expression (pushes value to stack)
            self._compile_expression(element)

            # Store element at index in array
            self.bytecode.add_instruction(Instruction(opcode=Opcode.STORE_ELEMENT))

    def _compile_object_expression(self, expr: ObjectExpression) -> None:
        """
        Compile an object literal expression.

        Generates bytecode to create an object and populate it with properties.
        Object remains on stack after compilation.

        Args:
            expr: ObjectExpression AST node

        Bytecode sequence:
            CREATE_OBJECT         # Create empty object, push to stack
            For each property:
                DUP               # Duplicate object reference
                <value>           # Compile value expression
                <key>             # Load or compute property key
                STORE_PROPERTY    # Store property in object
        """
        # Create empty object
        self.bytecode.add_instruction(Instruction(opcode=Opcode.CREATE_OBJECT))

        # Add each property to the object
        for prop in expr.properties:
            # Duplicate object reference (so it stays on stack)
            self.bytecode.add_instruction(Instruction(opcode=Opcode.DUP))

            # Compile property value
            self._compile_expression(prop.value)

            # Get property key
            if prop.computed:
                # Computed property: [expr]: value
                # Compile the key expression
                self._compile_expression(prop.key)
            else:
                # Normal property: key: value or shorthand {key}
                # Extract key name from Identifier or Literal
                if isinstance(prop.key, Identifier):
                    key_name = prop.key.name
                elif isinstance(prop.key, Literal):
                    key_name = str(prop.key.value)
                else:
                    raise CompileError(
                        f"Unsupported property key type: {type(prop.key).__name__}"
                    )

                # Load key as constant
                key_index = self.bytecode.add_constant(key_name)
                self.bytecode.add_instruction(
                    Instruction(opcode=Opcode.LOAD_CONSTANT, operand1=key_index)
                )

            # Store property in object
            self.bytecode.add_instruction(Instruction(opcode=Opcode.STORE_PROPERTY))

    def _compile_arrow_function_expression(self, node: ArrowFunctionExpression) -> None:
        """
        Compile an arrow function expression.

        Arrow functions are anonymous functions with concise syntax. They support
        two body forms:
        - Expression body: x => x * 2 (implicit return)
        - Block body: x => { return x * 2; } (explicit return)

        Args:
            node: ArrowFunctionExpression AST node

        Bytecode sequence:
            CREATE_FUNCTION param_count, function_bytecode

        The function bytecode contains:
            For expression body:
                <expression bytecode>
                RETURN
            For block body:
                <block bytecode>
                LOAD_UNDEFINED  # Implicit return if no explicit return
                RETURN
        """
        # Extract parameter names
        param_names = [param.name for param in node.params]
        param_count = len(param_names)

        # Save current bytecode context
        saved_bytecode = self.bytecode
        saved_locals = self.locals.copy()
        saved_next_local_index = self.next_local_index

        # Create new bytecode for function body
        self.bytecode = BytecodeArray(local_count=param_count)
        self.locals = {}
        self.next_local_index = 0

        # Declare parameters as local variables
        for param_name in param_names:
            local_index = self.next_local_index
            self.locals[param_name] = local_index
            self.next_local_index += 1

        # Compile function body based on type
        if isinstance(node.body, BlockStatement):
            # Block body: compile statements normally
            for statement in node.body.body:
                self._compile_statement(statement)

            # Add implicit return undefined at end (in case no explicit return)
            self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_UNDEFINED))
            self.bytecode.add_instruction(Instruction(opcode=Opcode.RETURN))
        else:
            # Expression body: compile expression and add implicit return
            self._compile_expression(node.body)
            self.bytecode.add_instruction(Instruction(opcode=Opcode.RETURN))

        # Get compiled function bytecode
        function_bytecode = self.bytecode

        # Set local count for function
        function_bytecode.local_count = self.next_local_index

        # Restore parent context
        self.bytecode = saved_bytecode
        self.locals = saved_locals
        self.next_local_index = saved_next_local_index

        # Emit CREATE_CLOSURE instruction
        # operand1: parameter count
        # operand2: function bytecode
        self.bytecode.add_instruction(
            Instruction(
                opcode=Opcode.CREATE_CLOSURE,
                operand1=param_count,
                operand2=function_bytecode,
            )
        )

    def _compile_function_declaration(self, node: FunctionDeclaration) -> None:
        """
        Compile a function declaration.

        Function declarations create a function and store it in a variable
        with the function's name. Unlike arrow functions, they have a name
        and must be stored as a variable.

        Example:
            function add(a, b) { return a + b; }

        Compiles to:
            CREATE_CLOSURE param_count, function_bytecode
            STORE_GLOBAL "add"  (or STORE_LOCAL if in function scope)

        Args:
            node: FunctionDeclaration AST node
        """
        # Extract function details
        function_name = node.name
        param_names = node.parameters
        param_count = len(param_names)
        function_body = node.body

        # Save current bytecode context
        saved_bytecode = self.bytecode
        saved_locals = self.locals.copy()
        saved_next_local_index = self.next_local_index

        # Create new bytecode for function body
        self.bytecode = BytecodeArray(local_count=param_count)
        self.locals = {}
        self.next_local_index = 0

        # Declare parameters as local variables
        for param_name in param_names:
            local_index = self.next_local_index
            self.locals[param_name] = local_index
            self.next_local_index += 1

        # Compile function body (always a BlockStatement)
        for statement in function_body.body:
            self._compile_statement(statement)

        # Add implicit return undefined at end (in case no explicit return)
        self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_UNDEFINED))
        self.bytecode.add_instruction(Instruction(opcode=Opcode.RETURN))

        # Get compiled function bytecode
        function_bytecode = self.bytecode

        # Set local count for function
        function_bytecode.local_count = self.next_local_index

        # Restore parent context
        self.bytecode = saved_bytecode
        self.locals = saved_locals
        self.next_local_index = saved_next_local_index

        # Emit CREATE_CLOSURE instruction to create the function
        self.bytecode.add_instruction(
            Instruction(
                opcode=Opcode.CREATE_CLOSURE,
                operand1=param_count,
                operand2=function_bytecode,
            )
        )

        # CRITICAL FIX: Store the function in a variable with its name
        # This makes the function accessible for later calls
        if function_name in self.locals:
            # Function declared inside another function - use local storage
            local_index = self.locals[function_name]
            self.bytecode.add_instruction(
                Instruction(opcode=Opcode.STORE_LOCAL, operand1=local_index)
            )
        else:
            # Function declared at top level - use global storage
            name_index = self.bytecode.add_constant(function_name)
            self.bytecode.add_instruction(
                Instruction(opcode=Opcode.STORE_GLOBAL, operand1=name_index)
            )
