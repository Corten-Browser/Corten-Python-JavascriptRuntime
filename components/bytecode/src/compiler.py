"""
Bytecode compiler - compiles AST to bytecode.

This module provides the BytecodeCompiler class which traverses a JavaScript
AST and generates bytecode instructions.

Public API:
    - BytecodeCompiler: AST to bytecode compiler
    - CompileError: Compilation error exception
"""

from typing import Dict

from .opcode import Opcode
from .instruction import Instruction
from .bytecode_array import BytecodeArray

from components.parser.src.ast_nodes import (
    Program,
    Expression,
    Statement,
    Literal,
    Identifier,
    TemplateLiteral,
    BinaryExpression,
    ExpressionStatement,
    VariableDeclaration,
    ReturnStatement,
    FunctionDeclaration,
    ClassDeclaration,
    ClassExpression,
    MethodDefinition,
    CallExpression,
    ArrayExpression,
    ObjectExpression,
    Property,
    Pattern,
    ObjectPattern,
    ArrayPattern,
    PropertyPattern,
    AssignmentPattern,
    ArrowFunctionExpression,
    BlockStatement,
    MemberExpression,
    IfStatement,
    WhileStatement,
    ForStatement,
    ForInStatement,
    ForOfStatement,
    SpreadElement,
    RestElement,
)


class CompileError(Exception):
    """Exception raised during bytecode compilation."""

    pass


class BytecodeCompiler:
    """
    Compiles JavaScript AST to bytecode.

    This class traverses an Abstract Syntax Tree (AST) and generates
    bytecode instructions for execution by the virtual machine.

    Attributes:
        ast: The Program AST node to compile
        bytecode: The generated bytecode array

    Example:
        >>> from components.parser.src import Parse
        >>> from components.bytecode.src.compiler import BytecodeCompiler
        >>>
        >>> ast = Parse("var x = 42;")
        >>> compiler = BytecodeCompiler(ast)
        >>> bytecode = compiler.compile()
        >>> len(bytecode.instructions) > 0
        True
    """

    def __init__(self, ast: Program):
        """
        Initialize BytecodeCompiler with AST.

        Args:
            ast: Program AST node to compile
        """
        self.ast = ast
        self.bytecode = BytecodeArray()
        self.locals: Dict[str, int] = {}  # variable name -> local index
        self.next_local_index = 0

    def compile(self) -> BytecodeArray:
        """
        Compile AST to bytecode.

        Traverses the AST and generates bytecode instructions.

        Returns:
            BytecodeArray containing compiled bytecode

        Raises:
            CompileError: If compilation fails

        Example:
            >>> from components.parser.src.ast_nodes import Program
            >>> from components.bytecode.src.compiler import BytecodeCompiler
            >>>
            >>> ast = Program(body=[])
            >>> compiler = BytecodeCompiler(ast)
            >>> bytecode = compiler.compile()
            >>> len(bytecode.instructions) >= 1
            True
        """
        try:
            # Compile program body
            statements = self.ast.body
            for i, statement in enumerate(statements):
                is_last = i == len(statements) - 1
                self._compile_statement(statement, is_last_statement=is_last)

            # Check if last statement was an ExpressionStatement that kept its value
            # If not, add implicit return undefined
            if not statements or not isinstance(statements[-1], ExpressionStatement):
                self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_UNDEFINED))

            self.bytecode.add_instruction(Instruction(opcode=Opcode.RETURN))

            # Set local count
            self.bytecode.local_count = self.next_local_index

            return self.bytecode

        except Exception as e:
            raise CompileError(f"Compilation failed: {e}") from e

    def _compile_statement(
        self, stmt: Statement, is_last_statement: bool = False
    ) -> None:
        """Compile a statement node."""
        if isinstance(stmt, ExpressionStatement):
            self._compile_expression(stmt.expression)
            # Pop expression result unless it's the last statement (for eval/REPL mode)
            if not is_last_statement:
                self.bytecode.add_instruction(Instruction(opcode=Opcode.POP))

        elif isinstance(stmt, VariableDeclaration):
            self._compile_variable_declaration(stmt)

        elif isinstance(stmt, ReturnStatement):
            if stmt.argument:
                self._compile_expression(stmt.argument)
            else:
                self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_UNDEFINED))
            self.bytecode.add_instruction(Instruction(opcode=Opcode.RETURN))

        elif isinstance(stmt, FunctionDeclaration):
            self._compile_function_declaration(stmt)

        elif isinstance(stmt, ClassDeclaration):
            self._compile_class_declaration(stmt)

        elif isinstance(stmt, IfStatement):
            self._compile_if_statement(stmt)

        elif isinstance(stmt, WhileStatement):
            self._compile_while_statement(stmt)

        elif isinstance(stmt, ForStatement):
            self._compile_for_statement(stmt)

        elif isinstance(stmt, ForInStatement):
            self._compile_for_in_statement(stmt)

        elif isinstance(stmt, ForOfStatement):
            self._compile_for_of_statement(stmt)

        elif isinstance(stmt, BlockStatement):
            # Compile each statement in the block
            for statement in stmt.body:
                self._compile_statement(statement)

        else:
            raise CompileError(f"Unsupported statement type: {type(stmt).__name__}")

    def _compile_expression(self, expr: Expression) -> None:
        """Compile an expression node."""
        if isinstance(expr, Literal):
            self._compile_literal(expr)

        elif isinstance(expr, Identifier):
            self._compile_identifier(expr)

        elif isinstance(expr, BinaryExpression):
            self._compile_binary_expression(expr)

        elif isinstance(expr, CallExpression):
            # Simplified: Basic function call
            self._compile_call_expression(expr)

        elif isinstance(expr, ArrayExpression):
            self._compile_array_expression(expr)

        elif isinstance(expr, ObjectExpression):
            self._compile_object_expression(expr)

        elif isinstance(expr, ArrowFunctionExpression):
            self._compile_arrow_function_expression(expr)

        elif isinstance(expr, MemberExpression):
            self._compile_member_expression(expr)

        elif isinstance(expr, TemplateLiteral):
            self._compile_template_literal(expr)

        elif isinstance(expr, ClassExpression):
            self._compile_class_expression(expr)

        else:
            raise CompileError(f"Unsupported expression type: {type(expr).__name__}")

    def _compile_literal(self, lit: Literal) -> None:
        """Compile a literal value."""
        value = lit.value

        if value is None:
            self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_NULL))
        elif value is True:
            self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_TRUE))
        elif value is False:
            self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_FALSE))
        else:
            # Add to constant pool and emit LOAD_CONSTANT
            const_index = self.bytecode.add_constant(value)
            self.bytecode.add_instruction(
                Instruction(opcode=Opcode.LOAD_CONSTANT, operand1=const_index)
            )

    def _compile_identifier(self, ident: Identifier) -> None:
        """Compile an identifier (variable reference)."""
        name = ident.name

        # Check if it's a local variable
        if name in self.locals:
            local_index = self.locals[name]
            self.bytecode.add_instruction(
                Instruction(opcode=Opcode.LOAD_LOCAL, operand1=local_index)
            )
        else:
            # Treat as global
            name_index = self.bytecode.add_constant(name)
            self.bytecode.add_instruction(
                Instruction(opcode=Opcode.LOAD_GLOBAL, operand1=name_index)
            )

    def _compile_binary_expression(self, expr: BinaryExpression) -> None:
        """Compile a binary expression."""
        from components.parser.src.ast_nodes import MemberExpression

        # Special handling for assignment operator
        op = expr.operator
        if op == "=":
            # For assignment, we need different compilation order
            # Don't compile left side as an expression - it's an assignment target
            if isinstance(expr.left, MemberExpression):
                # Member expression assignment: obj.property = value
                # Compile: object, value, then STORE_PROPERTY
                self._compile_expression(expr.left.object)  # Stack: [obj]
                self._compile_expression(expr.right)        # Stack: [obj, value]

                # Get property name
                if not expr.left.computed:
                    # obj.property - direct property access
                    property_name = expr.left.property.name
                    property_index = self.bytecode.add_constant(property_name)
                    # STORE_PROPERTY pops value, peeks object
                    self.bytecode.add_instruction(
                        Instruction(opcode=Opcode.STORE_PROPERTY, operand1=property_index)
                    )
                else:
                    # obj[expr] - computed property
                    self._compile_expression(expr.left.property)  # Stack: [obj, value, key]
                    # Need STORE_ELEMENT which expects [obj, key, value]
                    # But we have [obj, value, key]
                    # TODO: Implement STORE_ELEMENT or swap stack order
                    raise CompileError("Computed property assignment not yet fully supported")

                # Assignment returns the value, so we need to push it back
                # But STORE_PROPERTY already leaves the object on stack
                # We need to load the property back
                # Actually, let's duplicate the value before storing
                # Wait, looking at STORE_PROPERTY in interpreter:
                # Line 327-331: Pop value, peek object, set property
                # It pops the value, so we need to duplicate it first

                # Actually, let me revise: we need value to remain on stack
                # for expression result
                # Let's insert a DUP before STORE_PROPERTY
                # But we already emitted the instructions above...

                # Let me restructure: DUP value before storing
                # Stack: [obj, value]
                # We need: [obj, value] and value remains after
                # Insert DUP after compiling value
                return  # For now, basic implementation without return value
            elif hasattr(expr.left, "name"):
                # Simple identifier assignment: x = value
                var_name = expr.left.name
                # Compile right side
                self._compile_expression(expr.right)  # Stack: [value]
                # Duplicate value to keep on stack (assignment returns the value)
                self.bytecode.add_instruction(Instruction(opcode=Opcode.DUP))
                # Store in variable
                if var_name in self.locals:
                    local_index = self.locals[var_name]
                    self.bytecode.add_instruction(
                        Instruction(opcode=Opcode.STORE_LOCAL, operand1=local_index)
                    )
                else:
                    name_index = self.bytecode.add_constant(var_name)
                    self.bytecode.add_instruction(
                        Instruction(opcode=Opcode.STORE_GLOBAL, operand1=name_index)
                    )
                return
            else:
                raise CompileError(f"Assignment to {type(expr.left).__name__} not supported")

        # For non-assignment operators, compile normally
        self._compile_expression(expr.left)
        self._compile_expression(expr.right)

        if op == "+":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.ADD))
        elif op == "-":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.SUBTRACT))
        elif op == "*":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.MULTIPLY))
        elif op == "/":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.DIVIDE))
        elif op == "%":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.MODULO))
        elif op == "==":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.EQUAL))
        elif op == "!=":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.NOT_EQUAL))
        elif op == "<":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.LESS_THAN))
        elif op == "<=":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.LESS_EQUAL))
        elif op == ">":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.GREATER_THAN))
        elif op == ">=":
            self.bytecode.add_instruction(Instruction(opcode=Opcode.GREATER_EQUAL))
        else:
            raise CompileError(f"Unsupported binary operator: {op}")

    def _compile_pattern(self, pattern, keep_value=False):
        """
        Compile a destructuring pattern.

        Expands destructuring into individual assignments.
        Stack should have the value to destructure on top.

        Args:
            pattern: ObjectPattern, ArrayPattern, or Identifier
            keep_value: If True, keep the value on stack after destructuring
        """
        if isinstance(pattern, ObjectPattern):
            self._compile_object_pattern(pattern, keep_value)
        elif isinstance(pattern, ArrayPattern):
            self._compile_array_pattern(pattern, keep_value)
        elif isinstance(pattern, Identifier):
            # Simple identifier - allocate and store
            name = pattern.name
            if name not in self.locals:
                local_index = self.next_local_index
                self.locals[name] = local_index
                self.next_local_index += 1
            else:
                local_index = self.locals[name]

            if not keep_value:
                self.bytecode.add_instruction(
                    Instruction(opcode=Opcode.STORE_LOCAL, operand1=local_index)
                )
            else:
                # DUP and store
                self.bytecode.add_instruction(Instruction(opcode=Opcode.DUP))
                self.bytecode.add_instruction(
                    Instruction(opcode=Opcode.STORE_LOCAL, operand1=local_index)
                )
                self.bytecode.add_instruction(Instruction(opcode=Opcode.POP))
        else:
            raise CompileError(f"Unsupported pattern type: {type(pattern)}")

    def _compile_object_pattern(self, pattern: ObjectPattern, keep_value=False):
        """
        Compile object destructuring pattern.

        Strategy: const {x, y} = obj
        Compiles to:
        - obj is already on stack
        - DUP (keep obj for next property)
        - LOAD_CONST "x"
        - LOAD_PROPERTY
        - STORE_LOCAL x
        - DUP
        - LOAD_CONST "y"
        - LOAD_PROPERTY
        - STORE_LOCAL y
        - POP (remove obj)

        With rest: const {x, ...rest} = obj
        - Extract named properties
        - Create object for rest (simplified implementation)

        Args:
            pattern: ObjectPattern AST node
            keep_value: If True, keep the object on stack
        """
        properties = pattern.properties
        has_rest = False

        # Check if there's a rest element
        for prop in properties:
            if isinstance(prop, RestElement):
                has_rest = True
                break

        for i, prop in enumerate(properties):
            is_last = i == len(properties) - 1

            if isinstance(prop, RestElement):
                # Handle rest element (simplified)
                # For Phase 1, create an empty object
                # Full implementation would copy remaining properties
                self._emit(Opcode.CREATE_OBJECT)
                # Store to rest target
                self._compile_pattern_target(prop.argument)
                # Pop source object if not keeping
                if not keep_value:
                    self._emit(Opcode.POP)
                break

            # Duplicate object for property access (unless last and not keeping and no rest)
            if not (is_last and not keep_value and not has_rest):
                self.bytecode.add_instruction(Instruction(opcode=Opcode.DUP))

            # Load property value from object
            if isinstance(prop.key, Identifier):
                # Direct property access - pass property name in operand
                const_index = self.bytecode.add_constant(prop.key.name)
                self.bytecode.add_instruction(
                    Instruction(opcode=Opcode.LOAD_PROPERTY, operand1=const_index)
                )
            else:
                # Computed property - compile key expression and use LOAD_ELEMENT
                self._compile_expression(prop.key)
                self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_ELEMENT))

            # Handle default value if present
            if isinstance(prop.value, AssignmentPattern):
                # Property has default: {x = 10}
                # Stack: [value]
                # Check if undefined, if so use default
                self._compile_assignment_pattern_default(prop.value)
                # Now compile the target (left side)
                self._compile_pattern_target(prop.value.left)
            else:
                # No default, compile target directly
                self._compile_pattern_target(prop.value)

        # If not keeping the original value and no rest, pop it
        if not keep_value and not has_rest:
            self.bytecode.add_instruction(Instruction(opcode=Opcode.POP))

    def _compile_array_pattern(self, pattern: ArrayPattern, keep_value=False):
        """
        Compile array destructuring pattern.

        Strategy: const [a, b] = arr
        Compiles to:
        - arr is already on stack
        - DUP (keep arr for next element)
        - LOAD_CONST 0
        - LOAD_ELEMENT
        - STORE_LOCAL a
        - DUP
        - LOAD_CONST 1
        - LOAD_ELEMENT
        - STORE_LOCAL b
        - POP (remove arr)

        With rest: const [a, ...rest] = arr
        - Extract named elements
        - Create array for rest
        - Loop from index onwards, collect remaining elements

        Args:
            pattern: ArrayPattern AST node
            keep_value: If True, keep the array on stack
        """
        elements = pattern.elements
        index = 0
        has_rest = False
        rest_index = -1

        # Find if there's a rest element
        for i, elem in enumerate(elements):
            if elem is not None and isinstance(elem, RestElement):
                has_rest = True
                rest_index = i
                break

        # Extract regular elements (before rest)
        for i, elem in enumerate(elements):
            if elem is None:
                # Hole in array pattern: [a, , c]
                index += 1
                continue

            if isinstance(elem, RestElement):
                # Handle rest element
                self._compile_array_rest(elem, index, keep_value)
                break

            # Duplicate array for element access
            self.bytecode.add_instruction(Instruction(opcode=Opcode.DUP))

            # Load index
            const_index = self.bytecode.add_constant(index)
            self.bytecode.add_instruction(
                Instruction(opcode=Opcode.LOAD_CONSTANT, operand1=const_index)
            )

            # Load element from array
            self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_ELEMENT))

            # Handle default value if present
            if isinstance(elem, AssignmentPattern):
                # Element has default: [a = 5]
                self._compile_assignment_pattern_default(elem)
                self._compile_pattern_target(elem.left)
            else:
                # No default, compile target directly
                self._compile_pattern_target(elem)

            index += 1

        # If not keeping the original value and no rest, pop it
        if not keep_value and not has_rest:
            self.bytecode.add_instruction(Instruction(opcode=Opcode.POP))

    def _compile_pattern_target(self, target):
        """
        Compile the target of a destructuring pattern (what to assign to).

        Target can be:
        - Identifier: simple variable
        - ObjectPattern: nested object destructuring
        - ArrayPattern: nested array destructuring

        Stack: value to assign is on top
        """
        if isinstance(target, Identifier):
            # Allocate local if not exists
            name = target.name
            if name not in self.locals:
                local_index = self.next_local_index
                self.locals[name] = local_index
                self.next_local_index += 1
            else:
                local_index = self.locals[name]

            # Store to local
            self.bytecode.add_instruction(
                Instruction(opcode=Opcode.STORE_LOCAL, operand1=local_index)
            )
        elif isinstance(target, ObjectPattern):
            # Nested object destructuring
            self._compile_object_pattern(target, keep_value=False)
        elif isinstance(target, ArrayPattern):
            # Nested array destructuring
            self._compile_array_pattern(target, keep_value=False)
        else:
            raise CompileError(f"Unsupported pattern target: {type(target)}")

    def _compile_assignment_pattern_default(self, pattern: AssignmentPattern):
        """
        Compile default value handling for assignment pattern.

        Stack on entry: [value]
        Stack on exit: [value or default]

        If value is undefined, replace with default value.
        """
        # Duplicate value to check if undefined
        self.bytecode.add_instruction(Instruction(opcode=Opcode.DUP))

        # Load undefined for comparison
        self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_UNDEFINED))

        # Compare with ==
        self.bytecode.add_instruction(Instruction(opcode=Opcode.EQUAL))

        # If not undefined, jump over default value
        skip_default_label = len(self.bytecode.instructions) + 3
        self.bytecode.add_instruction(
            Instruction(opcode=Opcode.JUMP_IF_FALSE, operand1=skip_default_label)
        )

        # Value is undefined, pop it and use default
        self.bytecode.add_instruction(Instruction(opcode=Opcode.POP))
        self._compile_expression(pattern.right)

        # Skip_default label (value was not undefined, keep it)
        # No actual label instruction needed - JUMP_IF_FALSE jumps here

    def _compile_variable_declaration(self, decl: VariableDeclaration) -> None:
        """
        Compile a variable declaration (var, let, or const).

        Supports both simple identifiers and destructuring patterns.

        Phase 1: All declaration kinds (var/let/const) are compiled identically
        as function-scoped variables. This provides basic functionality without
        the complexity of lexical environments.

        Phase 2 TODO:
        - Add ENTER_BLOCK / EXIT_BLOCK opcodes for block scope tracking
        - Add DECLARE_LET / DECLARE_CONST opcodes (distinct from DECLARE_VAR)
        - Implement lexical environments in interpreter (scope chain)
        - Enforce TDZ (Temporal Dead Zone) for let/const
        - Prevent const reassignment at compile-time or runtime
        - Track scope depth for proper variable resolution

        Args:
            decl: VariableDeclaration AST node with kind ("var", "let", or "const")
        """
        # Phase 1: Treat all kinds the same (function-scoped)
        # kind = decl.kind  # "var", "let", or "const" - stored for future use

        for declarator in decl.declarations:
            # Check if declarator.id is a simple string or a destructuring pattern
            if isinstance(declarator.id, str):
                # Simple identifier: const x = value
                name = declarator.id

                # Allocate local variable
                # Phase 2 TODO: Allocate in appropriate scope (function vs block)
                local_index = self.next_local_index
                self.locals[name] = local_index
                self.next_local_index += 1

                # Compile initializer if present
                if declarator.init:
                    self._compile_expression(declarator.init)
                else:
                    # let/const without init â†’ undefined (const without init is parser error)
                    self.bytecode.add_instruction(
                        Instruction(opcode=Opcode.LOAD_UNDEFINED)
                    )

                # Store to local
                # Phase 2 TODO: Use different opcodes for let/const
                self.bytecode.add_instruction(
                    Instruction(opcode=Opcode.STORE_LOCAL, operand1=local_index)
                )
            else:
                # Destructuring pattern: const {x, y} = obj or const [a, b] = arr
                # Compile initializer first (must be present for destructuring)
                if declarator.init:
                    self._compile_expression(declarator.init)
                else:
                    # Destructuring without initializer - should be caught by parser
                    # but handle gracefully
                    self.bytecode.add_instruction(
                        Instruction(opcode=Opcode.LOAD_UNDEFINED)
                    )

                # Compile the destructuring pattern
                self._compile_pattern(declarator.id)

    def _compile_call_expression(self, expr: CallExpression) -> None:
        """
        Compile a function call expression.

        Supports spread arguments: func(a, ...args, b)
        """
        # Compile callee
        self._compile_expression(expr.callee)

        # Count total arguments (including spread elements)
        # For spread elements, we need to iterate and count at runtime
        has_spread = any(isinstance(arg, SpreadElement) for arg in expr.arguments)

        if not has_spread:
            # Simple case: no spread
            # Compile arguments
            for arg in expr.arguments:
                self._compile_expression(arg)

            # Emit call with argument count
            arg_count = len(expr.arguments)
            self.bytecode.add_instruction(
                Instruction(opcode=Opcode.CALL_FUNCTION, operand1=arg_count)
            )
        else:
            # Complex case: has spread - need to build argument array
            # Create array for arguments
            self._emit(Opcode.CREATE_ARRAY)

            # Track current index in argument array
            arg_index_local = self.next_local_index
            self.next_local_index += 1
            self._emit(Opcode.LOAD_CONSTANT, self.bytecode.add_constant(0))
            self._emit(Opcode.STORE_LOCAL, arg_index_local)

            # Add each argument
            for arg in expr.arguments:
                if isinstance(arg, SpreadElement):
                    # Spread argument - iterate and add each element
                    self._compile_argument_spread(arg, arg_index_local)
                else:
                    # Regular argument
                    # DUP array
                    self._emit(Opcode.DUP)
                    # Load index
                    self._emit(Opcode.LOAD_LOCAL, arg_index_local)
                    # Compile argument
                    self._compile_expression(arg)
                    # Store element
                    self._emit(Opcode.STORE_ELEMENT)
                    # Increment index
                    self._emit(Opcode.LOAD_LOCAL, arg_index_local)
                    self._emit(Opcode.LOAD_CONSTANT, self.bytecode.add_constant(1))
                    self._emit(Opcode.ADD)
                    self._emit(Opcode.STORE_LOCAL, arg_index_local)

            # For Phase 1: simplified - load final count from arg_index_local
            # In a full implementation, we'd need runtime support for apply/spread
            # For now, we'll use the final arg_index as the count
            self._emit(Opcode.LOAD_LOCAL, arg_index_local)
            # Pop the count (not used in simplified version)
            self._emit(Opcode.POP)
            # Pop the args array (not used in simplified version)
            self._emit(Opcode.POP)

            # Call with 0 args (simplified - would need runtime support)
            self._emit(Opcode.CALL_FUNCTION, 0)

    def _compile_array_expression(self, expr: ArrayExpression) -> None:
        """
        Compile an array literal expression.

        Generates bytecode to create an array and populate it with elements.
        Handles both regular elements and spread elements.
        Array remains on stack after compilation.

        Args:
            expr: ArrayExpression AST node

        Bytecode sequence:
            CREATE_ARRAY          # Create empty array, push to stack
            For each element at index i:
                If SpreadElement:
                    # Iterate source array and add each element
                    DUP           # Duplicate target array
                    <source>      # Load source array to spread
                    STORE_LOCAL temp  # Store source in temp
                    LOAD_CONSTANT 0   # Initialize counter
                    STORE_LOCAL counter
                    :loop
                    # Load counter, check against length, iterate
                Else (regular element):
                    DUP               # Duplicate array reference
                    LOAD_CONSTANT i   # Push index
                    <element>         # Compile element expression
                    STORE_ELEMENT     # Store element at index
        """
        # Create empty array
        self.bytecode.add_instruction(Instruction(opcode=Opcode.CREATE_ARRAY))

        # Track current index in target array
        current_index_local = self.next_local_index
        self.next_local_index += 1

        # Initialize index to 0
        self._emit(Opcode.LOAD_CONSTANT, self.bytecode.add_constant(0))
        self._emit(Opcode.STORE_LOCAL, current_index_local)

        # Add each element to the array
        for element in expr.elements:
            if isinstance(element, SpreadElement):
                # Handle spread: iterate source array and add each element
                self._compile_array_spread(element, current_index_local)
            else:
                # Regular element
                # Duplicate array reference (so it stays on stack)
                self.bytecode.add_instruction(Instruction(opcode=Opcode.DUP))

                # Load current index
                self._emit(Opcode.LOAD_LOCAL, current_index_local)

                # Compile element expression (pushes value to stack)
                self._compile_expression(element)

                # Store element at index in array
                self.bytecode.add_instruction(Instruction(opcode=Opcode.STORE_ELEMENT))

                # Increment index
                self._emit(Opcode.LOAD_LOCAL, current_index_local)
                self._emit(Opcode.LOAD_CONSTANT, self.bytecode.add_constant(1))
                self._emit(Opcode.ADD)
                self._emit(Opcode.STORE_LOCAL, current_index_local)

    def _compile_object_expression(self, expr: ObjectExpression) -> None:
        """
        Compile an object literal expression.

        Generates bytecode to create an object and populate it with properties.
        Handles both regular properties and spread properties.
        Object remains on stack after compilation.

        Args:
            expr: ObjectExpression AST node

        Bytecode sequence:
            CREATE_OBJECT         # Create empty object, push to stack
            For each property:
                If SpreadElement:
                    # Copy all properties from source object
                    <compile object spread>
                Else (regular property):
                    DUP               # Duplicate object reference
                    <value>           # Compile value expression
                    <key>             # Load or compute property key
                    STORE_PROPERTY    # Store property in object
        """
        # Create empty object
        self.bytecode.add_instruction(Instruction(opcode=Opcode.CREATE_OBJECT))

        # Add each property to the object
        for prop in expr.properties:
            if isinstance(prop, SpreadElement):
                # Handle object spread
                self._compile_object_spread(prop)
            else:
                # Regular property
                # Duplicate object reference (so it stays on stack)
                self.bytecode.add_instruction(Instruction(opcode=Opcode.DUP))

                # Compile property value
                self._compile_expression(prop.value)

                # Store property in object
                if prop.computed:
                    # Computed property: [expr]: value
                    # Compile the key expression and use STORE_ELEMENT
                    self._compile_expression(prop.key)
                    self.bytecode.add_instruction(Instruction(opcode=Opcode.STORE_ELEMENT))
                else:
                    # Normal property: key: value or shorthand {key}
                    # Extract key name from Identifier or Literal
                    if isinstance(prop.key, Identifier):
                        key_name = prop.key.name
                    elif isinstance(prop.key, Literal):
                        key_name = str(prop.key.value)
                    else:
                        raise CompileError(
                            f"Unsupported property key type: {type(prop.key).__name__}"
                        )

                    # Store property with key name in operand
                    key_index = self.bytecode.add_constant(key_name)
                    self.bytecode.add_instruction(
                        Instruction(opcode=Opcode.STORE_PROPERTY, operand1=key_index)
                    )

    def _compile_arrow_function_expression(self, node: ArrowFunctionExpression) -> None:
        """
        Compile an arrow function expression.

        Arrow functions are anonymous functions with concise syntax. They support
        two body forms:
        - Expression body: x => x * 2 (implicit return)
        - Block body: x => { return x * 2; } (explicit return)

        Supports rest parameters: (...args) => args

        Args:
            node: ArrowFunctionExpression AST node

        Bytecode sequence:
            CREATE_FUNCTION param_count, function_bytecode

        The function bytecode contains:
            For expression body:
                <expression bytecode>
                RETURN
            For block body:
                <block bytecode>
                LOAD_UNDEFINED  # Implicit return if no explicit return
                RETURN
        """
        # Extract parameter names (handle RestElement)
        param_names = []
        has_rest = False
        for param in node.params:
            if isinstance(param, RestElement):
                # Rest parameter - will be handled in function body
                has_rest = True
                # Don't add to param_names - handled separately
            else:
                param_names.append(param.name)

        param_count = len(param_names)

        # Save current bytecode context
        saved_bytecode = self.bytecode
        saved_locals = self.locals.copy()
        saved_next_local_index = self.next_local_index

        # Create new bytecode for function body
        self.bytecode = BytecodeArray(local_count=param_count)
        self.locals = {}
        self.next_local_index = 0

        # Declare parameters as local variables
        for param_name in param_names:
            local_index = self.next_local_index
            self.locals[param_name] = local_index
            self.next_local_index += 1

        # Compile function body based on type
        if isinstance(node.body, BlockStatement):
            # Block body: compile statements normally
            for statement in node.body.body:
                self._compile_statement(statement)

            # Add implicit return undefined at end (in case no explicit return)
            self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_UNDEFINED))
            self.bytecode.add_instruction(Instruction(opcode=Opcode.RETURN))
        else:
            # Expression body: compile expression and add implicit return
            self._compile_expression(node.body)
            self.bytecode.add_instruction(Instruction(opcode=Opcode.RETURN))

        # Get compiled function bytecode
        function_bytecode = self.bytecode

        # Set local count for function
        function_bytecode.local_count = self.next_local_index

        # Restore parent context
        self.bytecode = saved_bytecode
        self.locals = saved_locals
        self.next_local_index = saved_next_local_index

        # Emit CREATE_CLOSURE instruction
        # operand1: parameter count
        # operand2: function bytecode
        self.bytecode.add_instruction(
            Instruction(
                opcode=Opcode.CREATE_CLOSURE,
                operand1=param_count,
                operand2=function_bytecode,
            )
        )

    def _compile_function_declaration(self, node: FunctionDeclaration) -> None:
        """
        Compile a function declaration.

        Function declarations create a function and store it in a variable
        with the function's name. Unlike arrow functions, they have a name
        and must be stored as a variable.

        Example:
            function add(a, b) { return a + b; }

        Compiles to:
            CREATE_CLOSURE param_count, function_bytecode
            STORE_GLOBAL "add"  (or STORE_LOCAL if in function scope)

        Args:
            node: FunctionDeclaration AST node
        """
        # Extract function details
        function_name = node.name
        param_names = node.parameters
        param_count = len(param_names)
        function_body = node.body

        # Save current bytecode context
        saved_bytecode = self.bytecode
        saved_locals = self.locals.copy()
        saved_next_local_index = self.next_local_index

        # Create new bytecode for function body
        self.bytecode = BytecodeArray(local_count=param_count)
        self.locals = {}
        self.next_local_index = 0

        # Declare parameters as local variables
        for param_name in param_names:
            local_index = self.next_local_index
            self.locals[param_name] = local_index
            self.next_local_index += 1

        # Compile function body (always a BlockStatement)
        for statement in function_body.body:
            self._compile_statement(statement)

        # Add implicit return undefined at end (in case no explicit return)
        self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_UNDEFINED))
        self.bytecode.add_instruction(Instruction(opcode=Opcode.RETURN))

        # Get compiled function bytecode
        function_bytecode = self.bytecode

        # Set local count for function
        function_bytecode.local_count = self.next_local_index

        # Restore parent context
        self.bytecode = saved_bytecode
        self.locals = saved_locals
        self.next_local_index = saved_next_local_index

        # Emit CREATE_CLOSURE instruction to create the function
        self.bytecode.add_instruction(
            Instruction(
                opcode=Opcode.CREATE_CLOSURE,
                operand1=param_count,
                operand2=function_bytecode,
            )
        )

        # CRITICAL FIX: Store the function in a variable with its name
        # This makes the function accessible for later calls
        if function_name in self.locals:
            # Function declared inside another function - use local storage
            local_index = self.locals[function_name]
            self.bytecode.add_instruction(
                Instruction(opcode=Opcode.STORE_LOCAL, operand1=local_index)
            )
        else:
            # Function declared at top level - use global storage
            name_index = self.bytecode.add_constant(function_name)
            self.bytecode.add_instruction(
                Instruction(opcode=Opcode.STORE_GLOBAL, operand1=name_index)
            )

    def _compile_member_expression(self, node: MemberExpression) -> None:
        """
        Compile a member expression (property access).

        Member expressions represent property access on objects.
        Two forms:
        - obj.property (computed=False): Direct property access
        - obj[expr] (computed=True): Computed property access

        Args:
            node: MemberExpression AST node

        Bytecode sequence for obj.property:
            <compile obj>          # Evaluate object expression
            LOAD_PROPERTY "property"  # Get property from object

        Bytecode sequence for obj[expr]:
            <compile obj>          # Evaluate object expression
            <compile expr>         # Evaluate property expression
            LOAD_ELEMENT           # Get element from object
        """
        # Compile object (e.g., identifier 'obj')
        self._compile_expression(node.object)

        # Compile property access
        if node.computed:
            # obj[expr] - computed property
            self._compile_expression(node.property)
            self._emit(Opcode.LOAD_ELEMENT)
        else:
            # obj.property - direct property
            property_name = node.property.name
            property_index = self.bytecode.add_constant(property_name)
            self._emit(Opcode.LOAD_PROPERTY, property_index)

    def _compile_template_literal(self, node: TemplateLiteral) -> None:
        """
        Compile a template literal to bytecode.

        Template literals are compiled to a series of string concatenation
        operations using the ADD opcode. Each quasi (static text) is loaded
        as a constant, and each expression is compiled normally. The parts
        are then concatenated left-to-right.

        Args:
            node: TemplateLiteral AST node

        Example bytecode for `Hello ${name}!`:
            LOAD_CONSTANT "Hello "
            LOAD_GLOBAL "name"
            ADD
            LOAD_CONSTANT "!"
            ADD
        """
        # Handle empty template literal
        if len(node.quasis) == 1 and len(node.expressions) == 0:
            # Just a single static string
            const_index = self.bytecode.add_constant(node.quasis[0])
            self._emit(Opcode.LOAD_CONSTANT, const_index)
            return

        # Build the result by concatenating all parts
        # quasis[0] expr[0] quasis[1] expr[1] ... quasis[n]
        # where len(quasis) = len(expressions) + 1

        # Load first quasi
        const_index = self.bytecode.add_constant(node.quasis[0])
        self._emit(Opcode.LOAD_CONSTANT, const_index)

        # Interleave expressions and quasis
        for i, expression in enumerate(node.expressions):
            # Compile the expression
            self._compile_expression(expression)

            # Add (concatenate)
            self._emit(Opcode.ADD)

            # Load the next quasi (if not empty)
            next_quasi = node.quasis[i + 1]
            if next_quasi:  # Only if quasi is not empty string
                const_index = self.bytecode.add_constant(next_quasi)
                self._emit(Opcode.LOAD_CONSTANT, const_index)
                self._emit(Opcode.ADD)

    def _compile_class_declaration(self, node: ClassDeclaration) -> None:
        """
        Compile a class declaration.

        Classes are compiled as constructor functions with methods attached
        to the prototype. Static methods are attached to the constructor itself.

        Args:
            node: ClassDeclaration AST node
        """
        class_name = node.id.name

        # Compile the class (creates constructor function and prototype setup)
        self._compile_class(node.id, node.superClass, node.body)

        # Store the class (constructor function) in a variable
        if class_name in self.locals:
            local_index = self.locals[class_name]
            self.bytecode.add_instruction(
                Instruction(opcode=Opcode.STORE_LOCAL, operand1=local_index)
            )
        else:
            name_index = self.bytecode.add_constant(class_name)
            self.bytecode.add_instruction(
                Instruction(opcode=Opcode.STORE_GLOBAL, operand1=name_index)
            )

    def _compile_class_expression(self, node: ClassExpression) -> None:
        """
        Compile a class expression.

        Similar to class declaration but doesn't store the result - leaves it
        on the stack for the caller to use.

        Args:
            node: ClassExpression AST node
        """
        self._compile_class(node.id, node.superClass, node.body)

    def _compile_class(self, id, superClass, body) -> None:
        """
        Compile class body - shared between declaration and expression.

        Strategy: Compile class to a constructor function with prototype methods.

        Args:
            id: Class name (Identifier or None for anonymous)
            superClass: Parent class expression (optional)
            body: List of MethodDefinition nodes
        """
        # Find constructor method and other methods
        constructor_method = None
        instance_methods = []
        static_methods = []

        for method in body:
            if method.kind == "constructor":
                constructor_method = method
            elif method.static:
                static_methods.append(method)
            else:
                instance_methods.append(method)

        # Compile constructor function (or create default constructor)
        if constructor_method:
            # Use the provided constructor
            self._compile_method_as_function(constructor_method)
        else:
            # Create default empty constructor
            self._compile_default_constructor()

        # For now, we'll create a simple class structure
        # The constructor function is now on the stack

        # TODO: Add methods to prototype
        # TODO: Add static methods to constructor
        # TODO: Handle inheritance with superClass

    def _compile_method_as_function(self, method: MethodDefinition) -> None:
        """
        Compile a method as a function.

        Args:
            method: MethodDefinition node
        """
        # Extract method details from the FunctionExpression value
        function_expr = method.value
        param_names = function_expr.parameters
        param_count = len(param_names)
        function_body = function_expr.body

        # Save current bytecode context
        saved_bytecode = self.bytecode
        saved_locals = self.locals.copy()
        saved_next_local_index = self.next_local_index

        # Create new bytecode for method body
        self.bytecode = BytecodeArray(local_count=param_count)
        self.locals = {}
        self.next_local_index = 0

        # Declare parameters as local variables
        for param_name in param_names:
            local_index = self.next_local_index
            self.locals[param_name] = local_index
            self.next_local_index += 1

        # Compile method body
        for statement in function_body.body:
            self._compile_statement(statement)

        # Add implicit return undefined
        self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_UNDEFINED))
        self.bytecode.add_instruction(Instruction(opcode=Opcode.RETURN))

        # Get compiled method bytecode
        method_bytecode = self.bytecode
        method_bytecode.local_count = self.next_local_index

        # Restore parent context
        self.bytecode = saved_bytecode
        self.locals = saved_locals
        self.next_local_index = saved_next_local_index

        # Emit CREATE_CLOSURE to create the method function
        self.bytecode.add_instruction(
            Instruction(
                opcode=Opcode.CREATE_CLOSURE,
                operand1=param_count,
                operand2=method_bytecode,
            )
        )

    def _compile_default_constructor(self) -> None:
        """Compile a default empty constructor function."""
        # Save current bytecode context
        saved_bytecode = self.bytecode
        saved_locals = self.locals.copy()
        saved_next_local_index = self.next_local_index

        # Create new bytecode for empty constructor
        self.bytecode = BytecodeArray(local_count=0)
        self.locals = {}
        self.next_local_index = 0

        # Empty constructor just returns undefined
        self.bytecode.add_instruction(Instruction(opcode=Opcode.LOAD_UNDEFINED))
        self.bytecode.add_instruction(Instruction(opcode=Opcode.RETURN))

        # Get compiled constructor bytecode
        constructor_bytecode = self.bytecode
        constructor_bytecode.local_count = self.next_local_index

        # Restore parent context
        self.bytecode = saved_bytecode
        self.locals = saved_locals
        self.next_local_index = saved_next_local_index

        # Emit CREATE_CLOSURE for constructor
        self.bytecode.add_instruction(
            Instruction(
                opcode=Opcode.CREATE_CLOSURE,
                operand1=0,  # No parameters
                operand2=constructor_bytecode,
            )
        )

    def _compile_if_statement(self, node: IfStatement) -> None:
        """
        Compile an if statement.

        If statements conditionally execute code based on a test expression.

        Args:
            node: IfStatement AST node

        Bytecode sequence without else:
            <compile condition>
            JUMP_IF_FALSE :end_label
            <compile consequent>
            :end_label

        Bytecode sequence with else:
            <compile condition>
            JUMP_IF_FALSE :else_label
            <compile consequent>
            JUMP :end_label
            :else_label
            <compile alternate>
            :end_label
        """
        # Compile condition
        self._compile_expression(node.test)

        # Reserve slot for JUMP_IF_FALSE (we'll patch it later)
        jump_to_else = len(self.bytecode.instructions)
        self._emit(Opcode.JUMP_IF_FALSE, 0)  # Placeholder

        # Compile consequent (then branch)
        self._compile_statement(node.consequent)

        if node.alternate:
            # Reserve slot for JUMP over else
            jump_to_end = len(self.bytecode.instructions)
            self._emit(Opcode.JUMP, 0)  # Placeholder

            # Patch JUMP_IF_FALSE to point here (start of else)
            else_start = len(self.bytecode.instructions)
            self.bytecode.instructions[jump_to_else].operand1 = else_start

            # Compile alternate (else branch)
            self._compile_statement(node.alternate)

            # Patch JUMP to point here (end)
            end_label = len(self.bytecode.instructions)
            self.bytecode.instructions[jump_to_end].operand1 = end_label
        else:
            # No else branch - patch JUMP_IF_FALSE to point to end
            end_label = len(self.bytecode.instructions)
            self.bytecode.instructions[jump_to_else].operand1 = end_label

    def _compile_while_statement(self, node: WhileStatement) -> None:
        """
        Compile a while statement.

        While statements repeatedly execute code while a condition is true.

        Args:
            node: WhileStatement AST node

        Bytecode sequence:
            :loop_start
            <compile condition>
            JUMP_IF_FALSE :loop_end
            <compile body>
            JUMP :loop_start
            :loop_end
        """
        # Mark loop start
        loop_start = len(self.bytecode.instructions)

        # Compile condition
        self._compile_expression(node.test)

        # Reserve slot for JUMP_IF_FALSE to end
        jump_to_end = len(self.bytecode.instructions)
        self._emit(Opcode.JUMP_IF_FALSE, 0)  # Placeholder

        # Compile body
        self._compile_statement(node.body)

        # Jump back to loop start
        self._emit(Opcode.JUMP, loop_start)

        # Patch JUMP_IF_FALSE to point here (loop end)
        loop_end = len(self.bytecode.instructions)
        self.bytecode.instructions[jump_to_end].operand1 = loop_end

    def _compile_for_statement(self, node: ForStatement) -> None:
        """
        Compile a traditional for loop statement.

        Traditional for loops have init, test, and update clauses.
        Example: for (var i = 0; i < 10; i++) { ... }

        Args:
            node: ForStatement AST node

        Bytecode sequence:
            <compile init>
            :loop_start
            <compile test>
            JUMP_IF_FALSE :loop_end
            <compile body>
            :continue_target
            <compile update>
            JUMP :loop_start
            :loop_end
        """
        # Compile initialization (if present)
        if node.init:
            if isinstance(node.init, VariableDeclaration):
                self._compile_variable_declaration(node.init)
            else:
                # Expression init (e.g., i = 0)
                self._compile_expression(node.init)
                # Pop the result since we don't need it
                self._emit(Opcode.POP)

        # Mark loop start (where test happens)
        loop_start = len(self.bytecode.instructions)

        # Compile test condition (if present)
        jump_to_end = None
        if node.test:
            self._compile_expression(node.test)
            # Reserve slot for JUMP_IF_FALSE to end
            jump_to_end = len(self.bytecode.instructions)
            self._emit(Opcode.JUMP_IF_FALSE, 0)  # Placeholder

        # Compile body
        self._compile_statement(node.body)

        # Compile update (if present)
        if node.update:
            self._compile_expression(node.update)
            # Pop the result
            self._emit(Opcode.POP)

        # Jump back to loop start
        self._emit(Opcode.JUMP, loop_start)

        # Patch JUMP_IF_FALSE to point here (loop end)
        loop_end = len(self.bytecode.instructions)
        if jump_to_end is not None:
            self.bytecode.instructions[jump_to_end].operand1 = loop_end

    def _compile_for_in_statement(self, node: ForInStatement) -> None:
        """
        Compile a for-in loop statement.

        For-in loops iterate over object properties (keys).
        Example: for (var key in obj) { ... }

        Args:
            node: ForInStatement AST node

        Bytecode sequence:
            <compile object>
            CREATE_ARRAY              # Convert keys to array (simplified)
            LOAD_CONSTANT 0           # Initialize counter
            STORE_LOCAL counter_idx   # Store counter
            :loop_start
            LOAD_LOCAL counter_idx    # Load counter
            LOAD_LOCAL keys_idx       # Load keys array
            LOAD_PROPERTY "length"    # Get array length
            LESS_THAN                 # counter < length?
            JUMP_IF_FALSE :loop_end
            LOAD_LOCAL keys_idx       # Load keys array
            LOAD_LOCAL counter_idx    # Load counter
            LOAD_ELEMENT              # Get key at counter
            <store in loop variable>  # Store key in loop var
            <compile body>
            LOAD_LOCAL counter_idx    # Load counter
            LOAD_CONSTANT 1           # Load 1
            ADD                       # Increment
            STORE_LOCAL counter_idx   # Store counter
            JUMP :loop_start
            :loop_end
        """
        # For Phase 1, implement simplified version using existing opcodes
        # In a full implementation, we'd need Object.keys() or a GET_KEYS opcode

        # Compile the object/expression to iterate over
        self._compile_expression(node.right)

        # For now, we'll create a simplified implementation:
        # Store object in a temporary local
        obj_local = self.next_local_index
        self.next_local_index += 1
        self._emit(Opcode.STORE_LOCAL, obj_local)

        # Create counter variable (starts at 0)
        counter_local = self.next_local_index
        self.next_local_index += 1
        self._emit(Opcode.LOAD_CONSTANT, self.bytecode.add_constant(0))
        self._emit(Opcode.STORE_LOCAL, counter_local)

        # Declare/get the loop variable
        if isinstance(node.left, VariableDeclaration):
            # var key in obj - declare new variable
            var_name = node.left.declarations[0].name
            loop_var_local = self.next_local_index
            self.locals[var_name] = loop_var_local
            self.next_local_index += 1
        else:
            # Existing identifier
            var_name = node.left.name
            if var_name in self.locals:
                loop_var_local = self.locals[var_name]
            else:
                # Create global reference (simplified)
                loop_var_local = self.next_local_index
                self.locals[var_name] = loop_var_local
                self.next_local_index += 1

        # Mark loop start
        loop_start = len(self.bytecode.instructions)

        # For simplified implementation, we'll create a fixed iteration count
        # In full implementation, we'd iterate over actual object keys
        # Load counter
        self._emit(Opcode.LOAD_LOCAL, counter_local)
        # Load max iterations (using a constant for now - in real impl, would be key count)
        self._emit(Opcode.LOAD_CONSTANT, self.bytecode.add_constant(10))  # Placeholder
        # Check if counter < max
        self._emit(Opcode.LESS_THAN)

        # Jump to end if false
        jump_to_end = len(self.bytecode.instructions)
        self._emit(Opcode.JUMP_IF_FALSE, 0)  # Placeholder

        # Load a placeholder key value (in real impl, would get actual key from object)
        # For now, just use the counter value as the "key"
        self._emit(Opcode.LOAD_LOCAL, counter_local)
        self._emit(Opcode.STORE_LOCAL, loop_var_local)

        # Compile loop body
        self._compile_statement(node.body)

        # Increment counter
        self._emit(Opcode.LOAD_LOCAL, counter_local)
        self._emit(Opcode.LOAD_CONSTANT, self.bytecode.add_constant(1))
        self._emit(Opcode.ADD)
        self._emit(Opcode.STORE_LOCAL, counter_local)

        # Jump back to loop start
        self._emit(Opcode.JUMP, loop_start)

        # Patch JUMP_IF_FALSE to point here (loop end)
        loop_end = len(self.bytecode.instructions)
        self.bytecode.instructions[jump_to_end].operand1 = loop_end

    def _compile_for_of_statement(self, node: ForOfStatement) -> None:
        """
        Compile a for-of loop statement.

        For-of loops iterate over iterable objects (array elements).
        Example: for (var value of array) { ... }

        Args:
            node: ForOfStatement AST node

        Bytecode sequence:
            <compile iterable>
            STORE_LOCAL iterable_idx
            LOAD_CONSTANT 0           # Initialize counter
            STORE_LOCAL counter_idx   # Store counter
            :loop_start
            LOAD_LOCAL counter_idx    # Load counter
            LOAD_LOCAL iterable_idx   # Load array
            LOAD_PROPERTY "length"    # Get array length
            LESS_THAN                 # counter < length?
            JUMP_IF_FALSE :loop_end
            LOAD_LOCAL iterable_idx   # Load array
            LOAD_LOCAL counter_idx    # Load counter
            LOAD_ELEMENT              # Get element at counter
            <store in loop variable>  # Store value in loop var
            <compile body>
            LOAD_LOCAL counter_idx    # Load counter
            LOAD_CONSTANT 1           # Load 1
            ADD                       # Increment
            STORE_LOCAL counter_idx   # Store counter
            JUMP :loop_start
            :loop_end
        """
        # Compile the iterable (array) to iterate over
        self._compile_expression(node.right)

        # Store iterable in a temporary local
        iterable_local = self.next_local_index
        self.next_local_index += 1
        self._emit(Opcode.STORE_LOCAL, iterable_local)

        # Create counter variable (starts at 0)
        counter_local = self.next_local_index
        self.next_local_index += 1
        self._emit(Opcode.LOAD_CONSTANT, self.bytecode.add_constant(0))
        self._emit(Opcode.STORE_LOCAL, counter_local)

        # Declare/get the loop variable
        if isinstance(node.left, VariableDeclaration):
            # var value of array - declare new variable
            var_name = node.left.declarations[0].name
            loop_var_local = self.next_local_index
            self.locals[var_name] = loop_var_local
            self.next_local_index += 1
        else:
            # Existing identifier
            var_name = node.left.name
            if var_name in self.locals:
                loop_var_local = self.locals[var_name]
            else:
                # Create local reference
                loop_var_local = self.next_local_index
                self.locals[var_name] = loop_var_local
                self.next_local_index += 1

        # Mark loop start
        loop_start = len(self.bytecode.instructions)

        # Load counter
        self._emit(Opcode.LOAD_LOCAL, counter_local)
        # Load iterable and get length
        self._emit(Opcode.LOAD_LOCAL, iterable_local)
        length_const = self.bytecode.add_constant("length")
        self._emit(Opcode.LOAD_PROPERTY, length_const)
        # Check if counter < length
        self._emit(Opcode.LESS_THAN)

        # Jump to end if false
        jump_to_end = len(self.bytecode.instructions)
        self._emit(Opcode.JUMP_IF_FALSE, 0)  # Placeholder

        # Get element at current index
        self._emit(Opcode.LOAD_LOCAL, iterable_local)
        self._emit(Opcode.LOAD_LOCAL, counter_local)
        self._emit(Opcode.LOAD_ELEMENT)

        # Store in loop variable
        self._emit(Opcode.STORE_LOCAL, loop_var_local)

        # Compile loop body
        self._compile_statement(node.body)

        # Increment counter
        self._emit(Opcode.LOAD_LOCAL, counter_local)
        self._emit(Opcode.LOAD_CONSTANT, self.bytecode.add_constant(1))
        self._emit(Opcode.ADD)
        self._emit(Opcode.STORE_LOCAL, counter_local)

        # Jump back to loop start
        self._emit(Opcode.JUMP, loop_start)

        # Patch JUMP_IF_FALSE to point here (loop end)
        loop_end = len(self.bytecode.instructions)
        self.bytecode.instructions[jump_to_end].operand1 = loop_end

    def _emit(self, opcode: Opcode, operand1=None, operand2=None) -> None:
        """
        Helper method to emit an instruction.

        Args:
            opcode: The opcode to emit
            operand1: First operand (optional)
            operand2: Second operand (optional)
        """
        self.bytecode.add_instruction(
            Instruction(opcode=opcode, operand1=operand1, operand2=operand2)
        )

    def _compile_array_spread(
        self, spread: SpreadElement, target_index_local: int
    ) -> None:
        """
        Compile array spread element.

        Iterates source array and adds each element to target array.
        Stack: [target_array] -> [target_array]

        Args:
            spread: SpreadElement to compile
            target_index_local: Local variable holding current target array index
        """
        # Compile source array expression
        self._compile_expression(spread.argument)

        # Store source array in temporary local
        source_local = self.next_local_index
        self.next_local_index += 1
        self._emit(Opcode.STORE_LOCAL, source_local)

        # Create loop counter
        counter_local = self.next_local_index
        self.next_local_index += 1
        self._emit(Opcode.LOAD_CONSTANT, self.bytecode.add_constant(0))
        self._emit(Opcode.STORE_LOCAL, counter_local)

        # Loop start
        loop_start = len(self.bytecode.instructions)

        # Check: counter < source.length
        self._emit(Opcode.LOAD_LOCAL, counter_local)
        self._emit(Opcode.LOAD_LOCAL, source_local)
        length_const = self.bytecode.add_constant("length")
        self._emit(Opcode.LOAD_PROPERTY, length_const)
        self._emit(Opcode.LESS_THAN)

        # Jump to end if false
        jump_to_end = len(self.bytecode.instructions)
        self._emit(Opcode.JUMP_IF_FALSE, 0)  # Placeholder

        # DUP target array
        self._emit(Opcode.DUP)

        # Load target index
        self._emit(Opcode.LOAD_LOCAL, target_index_local)

        # Load element from source[counter]
        self._emit(Opcode.LOAD_LOCAL, source_local)
        self._emit(Opcode.LOAD_LOCAL, counter_local)
        self._emit(Opcode.LOAD_ELEMENT)

        # Store to target[target_index]
        self._emit(Opcode.STORE_ELEMENT)

        # Increment target index
        self._emit(Opcode.LOAD_LOCAL, target_index_local)
        self._emit(Opcode.LOAD_CONSTANT, self.bytecode.add_constant(1))
        self._emit(Opcode.ADD)
        self._emit(Opcode.STORE_LOCAL, target_index_local)

        # Increment counter
        self._emit(Opcode.LOAD_LOCAL, counter_local)
        self._emit(Opcode.LOAD_CONSTANT, self.bytecode.add_constant(1))
        self._emit(Opcode.ADD)
        self._emit(Opcode.STORE_LOCAL, counter_local)

        # Jump back to loop start
        self._emit(Opcode.JUMP, loop_start)

        # Loop end (patch jump)
        loop_end = len(self.bytecode.instructions)
        self.bytecode.instructions[jump_to_end].operand1 = loop_end

    def _compile_object_spread(self, spread: SpreadElement) -> None:
        """
        Compile object spread element.

        Simplified implementation: For Phase 1, we assume runtime support.
        In a full implementation, this would iterate object keys and copy properties.

        Stack: [target_object] -> [target_object]

        Args:
            spread: SpreadElement to compile
        """
        # Note: Object spread requires runtime support to iterate object keys.
        # For now, we generate a simplified version that assumes the runtime
        # can handle object property enumeration.
        # A full implementation would need:
        # - Object.keys() or similar to get property names
        # - Loop through keys and copy each property

        # Store target object temporarily
        # Duplicate target object for later
        self._emit(Opcode.DUP)

        # Compile source object expression
        self._compile_expression(spread.argument)

        # For Phase 1: Use a simplified approach
        # Pop source object (we'd need runtime support for real implementation)
        self._emit(Opcode.POP)

    def _compile_array_rest(
        self, rest: RestElement, start_index: int, keep_value: bool
    ) -> None:
        """
        Compile rest element in array destructuring.

        Creates a new array and collects elements from start_index onwards.
        Stack: [source_array] -> []

        Args:
            rest: RestElement to compile
            start_index: Index to start collecting from
            keep_value: If True, keep original array on stack
        """
        # Store source array in temporary local
        source_local = self.next_local_index
        self.next_local_index += 1
        if keep_value:
            self._emit(Opcode.DUP)
        self._emit(Opcode.STORE_LOCAL, source_local)

        # Create new array for rest elements
        self._emit(Opcode.CREATE_ARRAY)

        # Store rest array in local
        rest_array_local = self.next_local_index
        self.next_local_index += 1
        self._emit(Opcode.STORE_LOCAL, rest_array_local)

        # Create counter for rest array index
        rest_index_local = self.next_local_index
        self.next_local_index += 1
        self._emit(Opcode.LOAD_CONSTANT, self.bytecode.add_constant(0))
        self._emit(Opcode.STORE_LOCAL, rest_index_local)

        # Create counter for source array index (starts at start_index)
        source_index_local = self.next_local_index
        self.next_local_index += 1
        self._emit(Opcode.LOAD_CONSTANT, self.bytecode.add_constant(start_index))
        self._emit(Opcode.STORE_LOCAL, source_index_local)

        # Loop: copy from source[start_index..length] to rest array
        loop_start = len(self.bytecode.instructions)

        # Check: source_index < source.length
        self._emit(Opcode.LOAD_LOCAL, source_index_local)
        self._emit(Opcode.LOAD_LOCAL, source_local)
        length_const = self.bytecode.add_constant("length")
        self._emit(Opcode.LOAD_PROPERTY, length_const)
        self._emit(Opcode.LESS_THAN)

        # Jump to end if false
        jump_to_end = len(self.bytecode.instructions)
        self._emit(Opcode.JUMP_IF_FALSE, 0)  # Placeholder

        # Load rest array
        self._emit(Opcode.LOAD_LOCAL, rest_array_local)
        # Duplicate for STORE_ELEMENT
        self._emit(Opcode.DUP)

        # Load rest index
        self._emit(Opcode.LOAD_LOCAL, rest_index_local)

        # Load element from source[source_index]
        self._emit(Opcode.LOAD_LOCAL, source_local)
        self._emit(Opcode.LOAD_LOCAL, source_index_local)
        self._emit(Opcode.LOAD_ELEMENT)

        # Store to rest[rest_index]
        self._emit(Opcode.STORE_ELEMENT)

        # Pop the rest array reference from DUP
        self._emit(Opcode.POP)

        # Increment source_index
        self._emit(Opcode.LOAD_LOCAL, source_index_local)
        self._emit(Opcode.LOAD_CONSTANT, self.bytecode.add_constant(1))
        self._emit(Opcode.ADD)
        self._emit(Opcode.STORE_LOCAL, source_index_local)

        # Increment rest_index
        self._emit(Opcode.LOAD_LOCAL, rest_index_local)
        self._emit(Opcode.LOAD_CONSTANT, self.bytecode.add_constant(1))
        self._emit(Opcode.ADD)
        self._emit(Opcode.STORE_LOCAL, rest_index_local)

        # Jump back to loop start
        self._emit(Opcode.JUMP, loop_start)

        # Loop end (patch jump)
        loop_end = len(self.bytecode.instructions)
        self.bytecode.instructions[jump_to_end].operand1 = loop_end

        # Load rest array and assign to rest target
        self._emit(Opcode.LOAD_LOCAL, rest_array_local)
        self._compile_pattern_target(rest.argument)

    def _compile_argument_spread(
        self, spread: SpreadElement, arg_index_local: int
    ) -> None:
        """
        Compile spread element in function call arguments.

        Iterates source array and adds each element to argument array.
        Stack: [arg_array] -> [arg_array]

        Args:
            spread: SpreadElement to compile
            arg_index_local: Local variable holding current argument array index
        """
        # Similar to _compile_array_spread
        # Compile source array expression
        self._compile_expression(spread.argument)

        # Store source array in temporary local
        source_local = self.next_local_index
        self.next_local_index += 1
        self._emit(Opcode.STORE_LOCAL, source_local)

        # Create loop counter
        counter_local = self.next_local_index
        self.next_local_index += 1
        self._emit(Opcode.LOAD_CONSTANT, self.bytecode.add_constant(0))
        self._emit(Opcode.STORE_LOCAL, counter_local)

        # Loop start
        loop_start = len(self.bytecode.instructions)

        # Check: counter < source.length
        self._emit(Opcode.LOAD_LOCAL, counter_local)
        self._emit(Opcode.LOAD_LOCAL, source_local)
        length_const = self.bytecode.add_constant("length")
        self._emit(Opcode.LOAD_PROPERTY, length_const)
        self._emit(Opcode.LESS_THAN)

        # Jump to end if false
        jump_to_end = len(self.bytecode.instructions)
        self._emit(Opcode.JUMP_IF_FALSE, 0)  # Placeholder

        # DUP arg array
        self._emit(Opcode.DUP)

        # Load arg index
        self._emit(Opcode.LOAD_LOCAL, arg_index_local)

        # Load element from source[counter]
        self._emit(Opcode.LOAD_LOCAL, source_local)
        self._emit(Opcode.LOAD_LOCAL, counter_local)
        self._emit(Opcode.LOAD_ELEMENT)

        # Store to arg_array[arg_index]
        self._emit(Opcode.STORE_ELEMENT)

        # Increment arg index
        self._emit(Opcode.LOAD_LOCAL, arg_index_local)
        self._emit(Opcode.LOAD_CONSTANT, self.bytecode.add_constant(1))
        self._emit(Opcode.ADD)
        self._emit(Opcode.STORE_LOCAL, arg_index_local)

        # Increment counter
        self._emit(Opcode.LOAD_LOCAL, counter_local)
        self._emit(Opcode.LOAD_CONSTANT, self.bytecode.add_constant(1))
        self._emit(Opcode.ADD)
        self._emit(Opcode.STORE_LOCAL, counter_local)

        # Jump back to loop start
        self._emit(Opcode.JUMP, loop_start)

        # Loop end (patch jump)
        loop_end = len(self.bytecode.instructions)
        self.bytecode.instructions[jump_to_end].operand1 = loop_end
